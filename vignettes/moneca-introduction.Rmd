---
title: "Introduction to moneca: Mobility Network Clustering Analysis"
author: "Giampaolo Montaletti"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
    fig_width: 8
    fig_height: 6
vignette: >
  %\VignetteIndexEntry{Introduction to moneca: Mobility Network Clustering Analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "figures/",
  warning = FALSE,
  message = FALSE,
  fig.width = 10,
  fig.height = 8,
  dpi = 150,
  out.width = "100%"
)

# Check if required packages are available
required_packages <- c("ggplot2", "ggraph", "igraph", "dplyr", "tidygraph", "viridis", "RColorBrewer")
missing_packages <- required_packages[!sapply(required_packages, requireNamespace, quietly = TRUE)]

if (length(missing_packages) > 0) {
  knitr::opts_chunk$set(eval = FALSE)
  message("Some required packages are missing: ", paste(missing_packages, collapse = ", "))
  message("Code examples will not be evaluated.")
}
```

## Introduction

moneca (Mobility Network Clustering Analysis) is an R package that analyzes social mobility patterns through graph-theoretic approaches. The package creates weighted networks from mobility tables and uses cliques to identify discrete and nested clusters of positions with high internal mobility.

### About This Vignette

This vignette was written by **Giampaolo Montaletti** as part of the comprehensive modernization of the moneca package (2024). It provides a complete guide to using the modern features and capabilities of the package, including the new visualization system, synthetic data generation, and enhanced analysis tools.

### Package Background

The **moneca** package (lowercase) is a complete rewrite and modernization of the original MONECA package. While it implements the clustering algorithm originally developed by Touboel & Larsen (2017), the current package features entirely new code for visualization, testing, data generation, and documentation authored by Giampaolo Montaletti.

### Key Features

- **Network-based clustering** of mobility tables
- **Hierarchical segmentation** at multiple levels
- **Modern visualization** with ggplot2 and ggraph
- **Quality metrics** for assessing segmentation performance
- **Synthetic data generation** for testing and demonstrations

## Basic Concepts

Social mobility can be represented as a network where:

- **Nodes** represent social positions (occupations, classes, etc.)
- **Edges** represent mobility flows between positions
- **Edge weights** represent the strength of mobility connections
- **Clusters** represent groups of positions with high internal mobility

MONECA identifies these clusters by:

1. Converting mobility tables to relative risk matrices
2. Finding cliques in the weighted network
3. Iteratively aggregating positions into segments
4. Creating hierarchical segmentation levels

## Installation and Setup

```{r installation, eval=FALSE}
# Install from GitHub
devtools::install_github("gmontaletti/moneca")

# Load the package
library(moneca)

# Load additional packages for visualization
library(ggplot2)
library(ggraph)
```

```{r load_package, echo=FALSE}
# For vignette building
library(moneca)
```

## Working with Synthetic Data

MONECA includes functions to generate synthetic mobility data for demonstrations and testing.

### Creating Basic Synthetic Data

```{r synthetic_basic}
# Generate a large 30-class mobility table for better statistical analysis
basic_data <- generate_mobility_data(
  n_classes = 30,
  n_total = 50000,  # Larger population for better statistical power
  immobility_strength = 0.7,
  class_clustering = 0.2,
  class_names = paste("Class", sprintf("%02d", 1:30)),
  seed = 42
)

# View a subset of the structure to show key portions
cat("Mobility matrix dimensions:", dim(basic_data), "\n")
cat("Total population:", basic_data[31, 31], "\n\n")

# Show first 8x8 corner with totals to demonstrate structure
cat("First 8x8 corner of mobility matrix with marginal totals:\n")
subset_matrix <- basic_data[c(1:8, 31), c(1:8, 31)]
print(subset_matrix)

# Show diagonal (immobility) for first 10 classes
cat("\nImmobility rates for first 10 classes:\n")
diagonal_values <- diag(basic_data[1:30, 1:30])[1:10]
row_totals <- basic_data[1:10, 31]
immobility_rates <- round(diagonal_values / row_totals * 100, 1)
names(immobility_rates) <- paste("Class", sprintf("%02d", 1:10))
print(immobility_rates)
```

The mobility matrix shows:
- **Rows**: Origin classes (where people start)
- **Columns**: Destination classes (where people end up)
- **Last row/column**: Marginal totals
- **Diagonal**: Immobility (staying in same class)

### Creating Different Mobility Scenarios

```{r synthetic_scenarios}
# Get multiple example datasets (note: these are pre-configured examples)
examples <- generate_example_datasets()
cat("Available example datasets:\\n")
names(examples)

# For demonstration of larger networks, create custom 30x30 examples
cat("\\n\\nCreating custom 30x30 examples for comparison:\\n")

# Create 30x30 rigid system
examples_30x30 <- list()
examples_30x30$rigid <- generate_mobility_data(
  n_classes = 30,
  n_total = 45000,
  immobility_strength = 0.85,  # Very rigid
  class_clustering = 0.9,
  class_names = paste("Class", sprintf("%02d", 1:30)),
  seed = 100
)

# Create 30x30 fluid system
examples_30x30$fluid <- generate_mobility_data(
  n_classes = 30,
  n_total = 45000,
  immobility_strength = 0.4,  # Very fluid
  class_clustering = 0.6,
  class_names = paste("Class", sprintf("%02d", 1:30)),
  seed = 200
)

# Examine the rigid class system - show key portions
cat("Rigid class system (30x30 matrix):\n")
cat("Matrix dimensions:", dim(examples_30x30$rigid), "\n")
cat("Total population:", examples_30x30$rigid[31, 31], "\n\n")

# Show first 6x6 corner with totals
cat("First 6x6 corner with marginal totals:\n")
rigid_subset <- examples_30x30$rigid[c(1:6, 31), c(1:6, 31)]
print(rigid_subset)

# Show immobility rates for first 8 classes
cat("\nImmobility rates (%) for first 8 classes in rigid system:\n")
rigid_diag <- diag(examples_30x30$rigid[1:30, 1:30])[1:8]
rigid_totals <- examples_30x30$rigid[1:8, 31]
rigid_rates <- round(rigid_diag / rigid_totals * 100, 1)
names(rigid_rates) <- paste("Class", sprintf("%02d", 1:8))
print(rigid_rates)

# Examine the fluid (highly mobile) system
cat("\nFluid mobility system (30x30 matrix):\n")
cat("Matrix dimensions:", dim(examples_30x30$fluid), "\n")
cat("Total population:", examples_30x30$fluid[31, 31], "\n\n")

# Show first 6x6 corner with totals
cat("First 6x6 corner with marginal totals:\n")
fluid_subset <- examples_30x30$fluid[c(1:6, 31), c(1:6, 31)]
print(fluid_subset)

# Show immobility rates for first 8 classes
cat("\nImmobility rates (%) for first 8 classes in fluid system:\n")
fluid_diag <- diag(examples_30x30$fluid[1:30, 1:30])[1:8]
fluid_totals <- examples_30x30$fluid[1:8, 31]
fluid_rates <- round(fluid_diag / fluid_totals * 100, 1)
names(fluid_rates) <- paste("Class", sprintf("%02d", 1:8))
print(fluid_rates)
```

## Running MONECA Analysis

### Basic Analysis

```{r basic_analysis}
# Run MONECA on the basic dataset
seg <- moneca(basic_data, segment.levels = 3)

# View the results
print(seg)
```

The MONECA object contains:
- `segment.list`: Hierarchical clusters for each level
- `mat.list`: Aggregated mobility matrices for each level

### Understanding the Results

```{r understand_results}
# View segment membership
membership <- segment.membership(seg)
cat("Segment membership summary:\n")
cat("Number of levels:", length(membership), "\n")
for(i in 1:length(membership)) {
  cat("Level", i, "- Number of segments:", length(unique(membership[[i]])), "\n")
}

# Show first 15 class memberships at each level
cat("\nSegment membership for first 15 classes:\n")
membership_subset <- data.frame(
  Class = paste("Class", sprintf("%02d", 1:15)),
  Level_1 = membership[[1]][1:15],
  Level_2 = membership[[2]][1:15]
)
if(length(membership) >= 3) {
  membership_subset$Level_3 <- membership[[3]][1:15]
}
print(membership_subset)

# View the aggregated matrix for level 2
cat("\nLevel 2 aggregated matrix dimensions:", dim(seg$mat.list[[2]]), "\n")
print("Level 2 aggregated matrix:")
print(seg$mat.list[[2]])
```

## Modern Visualization with ggraph

MONECA now includes modern visualization functions using ggplot2 and ggraph, designed with accessibility and clarity as primary concerns.

### Visualization Design Principles

All MONECA plotting functions follow evidence-based design principles for maximum accessibility and clarity:

1. **Colorblind Accessibility**: Uses viridis, plasma, and ColorBrewer palettes that are perceptually uniform and distinguishable for all types of color vision
2. **High Contrast**: Maintains WCAG AA contrast ratios for text and visual elements
3. **Redundant Encoding**: Uses both color and other visual properties (size, shape, position) to encode information
4. **Clear Visual Hierarchy**: Guides attention through strategic use of size, transparency, and positioning
5. **Minimal Cognitive Load**: Reduces visual clutter while maintaining analytical depth

```{r accessibility_demo, eval=FALSE}
# Example of accessibility-focused plotting
plot_moneca_ggraph(
  seg,
  color_palette = "Set2",       # Colorblind-safe qualitative palette
  node_alpha = 0.85,            # High contrast
  edge_alpha = 0.6,             # Balanced visibility
  show_segments = TRUE,         # Visual grouping
  segment_alpha = 0.2,          # Subtle boundaries
  label_size = 3.5              # Readable text
)

# For continuous variables, use viridis family
plot_moneca_ggraph(
  seg,
  node_color = "mobility",      # Color by mobility rates
  color_palette = "viridis",    # Colorblind-safe continuous scale
  node_alpha = 0.85,
  edge_alpha = 0.6
)
```

### Basic Network Plot with Colorblind-Friendly Design

```{r plot_basic, eval=TRUE, fig.width=8, fig.height=6}
# Create a basic network plot with improved accessibility
# Using viridis color palette (colorblind-friendly) and optimized layout
# Note: Node colors represent segment membership, sizes show total mobility
p1 <- plot_moneca_ggraph(
  seg,
  title = "Social Mobility Network: Hierarchical Segmentation",
  layout = "stress",  # Better layout for clear network structure
  node_color = "segment",
  node_size = "total",
  color_palette = "Set2",  # Colorblind-friendly palette
  node_alpha = 0.85,
  edge_alpha = 0.7,
  show_segments = TRUE,
  segment_alpha = 0.2,
  label_size = 3.5
)

print(p1)
```

### Advanced Network Visualization with Clear Segment Boundaries

```{r plot_custom, eval=TRUE, fig.width=12, fig.height=10}
# Create an advanced plot emphasizing segment structure for 30-node network
# Note: For larger networks, reduce label clutter and focus on structure
p2 <- plot_moneca_ggraph(
  seg,
  layout = "fr",  # Force-directed layout for balanced positioning
  node_color = "segment",
  node_size = "mobility",  # Size by mobility rate for analytical insight
  edge_width = "weight",
  color_palette = "Dark2",  # High-contrast ColorBrewer palette
  edge_color = "grey30",  # Darker edges for better visibility
  theme_style = "minimal",
  title = "Advanced MONECA Network Analysis (30 Classes)",
  show_labels = FALSE,  # Turn off labels for 30-node network to reduce clutter
  show_segments = TRUE,
  segment_alpha = 0.15,
  node_alpha = 0.9,
  edge_alpha = 0.6
)

print(p2)

# Also create a subset visualization focusing on the largest segments
cat("\nLargest segments at Level 2:\n")
level2_segments <- seg$segment.list[[2]]
segment_sizes <- sapply(level2_segments, length)
largest_segments <- order(segment_sizes, decreasing = TRUE)[1:3]
cat("Segment sizes:", segment_sizes[largest_segments], "\n")
```

### Ego Network Analysis: Focus on Individual Position Dynamics

Ego networks reveal mobility patterns from a single focal position, showing both incoming and outgoing flows:

```{r ego_plot, eval=TRUE, fig.width=9, fig.height=7}
# Create ego network for class 15 (middle of the range) with enhanced accessibility
# Note: Red nodes show focal position and same-segment connections; Flow width indicates volume
p3 <- plot_ego_ggraph(
  seg,
  basic_data,
  ego_id = 15,  # Class 15 out of 30 classes
  layout = "stress",  # Stress layout for cleaner ego networks
  title = "Ego Network Analysis: Class 15 Mobility Patterns (30-Class System)",
  highlight_color = "#D55E00",  # Colorblind-safe orange-red
  flow_color = "plasma",  # Perceptually uniform color scale
  node_size_range = c(3, 12),
  edge_width_range = c(0.5, 4),
  min_weight = 50  # Higher threshold for 30-class system to filter weak connections
)

print(p3)

# Show ego network statistics
cat("\nEgo network statistics for Class 15:\n")
ego_connections <- which(basic_data[15, 1:30] > 50 | basic_data[1:30, 15] > 50)
cat("Classes connected to Class 15 (flows > 50):", length(ego_connections), "\n")
cat("Connected classes:", paste(ego_connections, collapse = ", "), "\n")
```

### Multi-Level Segmentation: Hierarchical Structure Visualization

```{r stair_plot, eval=TRUE, fig.width=12, fig.height=10}
# Create stair plots showing progressive segmentation for 30-class system
# Using consistent positioning to track segment evolution across levels
stair_plots <- plot_stair_ggraph(
  seg, 
  levels = 2:3,
  layout = NULL,  # Use consistent layout.matrix for position stability
  segment_naming = "auto",
  color_palette = "Set2",  # Colorblind-friendly qualitative palette
  node_size = "total",
  edge_alpha = 0.6,
  node_alpha = 0.85,
  segment_alpha = 0.2,
  label_size = 2.5  # Smaller labels for 30-node network
)

# Display individual plots with improved spacing
print(stair_plots$`Level 2`)
print(stair_plots$`Level 3`)

# Provide numerical summary of segmentation progression
cat("\nSegmentation progression summary:\n")
for(level in 2:3) {
  n_segments <- length(seg$segment.list[[level]])
  avg_size <- mean(sapply(seg$segment.list[[level]], length))
  cat("Level", level, ":", n_segments, "segments, average size", round(avg_size, 1), "classes\n")
}
```

## Advanced Analysis Examples

### Comparing Different Mobility Regimes

```{r compare_regimes}
# Analyze the rigid class system (30x30)
rigid_seg <- moneca(examples_30x30$rigid, segment.levels = 3)

# Analyze the fluid mobility system (30x30)
fluid_seg <- moneca(examples_30x30$fluid, segment.levels = 3)

# Compare segment memberships - show summary statistics
rigid_membership <- segment.membership(rigid_seg)
fluid_membership <- segment.membership(fluid_seg)

cat("Rigid system segmentation summary:\n")
for(i in 1:length(rigid_membership)) {
  n_segments <- length(unique(rigid_membership[[i]]))
  segment_sizes <- table(rigid_membership[[i]])
  avg_size <- mean(segment_sizes)
  max_size <- max(segment_sizes)
  cat("Level", i, ":", n_segments, "segments, avg size", round(avg_size, 1), 
      ", largest segment", max_size, "classes\n")
}

cat("\nFluid system segmentation summary:\n")
for(i in 1:length(fluid_membership)) {
  n_segments <- length(unique(fluid_membership[[i]]))
  segment_sizes <- table(fluid_membership[[i]])
  avg_size <- mean(segment_sizes)
  max_size <- max(segment_sizes)
  cat("Level", i, ":", n_segments, "segments, avg size", round(avg_size, 1), 
      ", largest segment", max_size, "classes\n")
}

# Show first 12 class memberships for comparison
cat("\nSegment membership comparison for first 12 classes:\n")
comparison_df <- data.frame(
  Class = paste("Class", sprintf("%02d", 1:12)),
  Rigid_L2 = rigid_membership[[2]][1:12],
  Fluid_L2 = fluid_membership[[2]][1:12]
)
if(length(rigid_membership) >= 3 && length(fluid_membership) >= 3) {
  comparison_df$Rigid_L3 <- rigid_membership[[3]][1:12]
  comparison_df$Fluid_L3 <- fluid_membership[[3]][1:12]
}
print(comparison_df)
```

### Comparing Mobility Regimes: Accessibility-Focused Visualizations

```{r compare_plots, eval=TRUE, fig.width=12, fig.height=8}
# Compare rigid vs fluid systems for 30-class networks
# Using colorblind-safe palettes and clear differentiation

# Plot rigid system - emphasis on strong boundaries
# Note: High immobility rates create distinct, well-separated segments
p_rigid <- plot_moneca_ggraph(
  rigid_seg,
  title = "Rigid Class System: Strong Internal Cohesion (30 Classes)",
  layout = "stress",
  node_color = "segment",
  node_size = "total",
  color_palette = "Oranges",  # Sequential palette for rigid structure
  edge_color = "grey20",
  show_segments = TRUE,
  segment_alpha = 0.25,
  node_alpha = 0.9,
  edge_alpha = 0.5,
  show_labels = FALSE  # No labels for 30-node network
)

# Plot fluid system - emphasis on connectivity
# Note: Strong cross-segment mobility creates overlapping, less distinct boundaries
p_fluid <- plot_moneca_ggraph(
  fluid_seg,
  title = "Fluid Mobility System: High Inter-Segment Flow (30 Classes)",
  layout = "stress",
  node_color = "segment",
  node_size = "mobility",  # Size by mobility rate to show fluidity
  color_palette = "Purples",  # Different sequential palette for contrast
  edge_color = "grey30",
  show_segments = TRUE,
  segment_alpha = 0.15,  # Lower alpha for fluid boundaries
  node_alpha = 0.85,
  edge_alpha = 0.7,  # Higher edge alpha to show connectivity
  show_labels = FALSE  # No labels for 30-node network
)

print(p_rigid)
print(p_fluid)

# Add network density comparison
cat("\nNetwork characteristics comparison:\n")
cat("Rigid system - segments at Level 2:", length(rigid_seg$segment.list[[2]]), "\n")
cat("Fluid system - segments at Level 2:", length(fluid_seg$segment.list[[2]]), "\n")

# Calculate edge densities
rigid_edges <- sum(!is.na(segment.edges(rigid_seg, level = 1)) & segment.edges(rigid_seg, level = 1) > 1)
fluid_edges <- sum(!is.na(segment.edges(fluid_seg, level = 1)) & segment.edges(fluid_seg, level = 1) > 1)
max_edges <- 30 * 29  # Directed graph

cat("Rigid system edge density:", round(rigid_edges / max_edges * 100, 1), "%\n")
cat("Fluid system edge density:", round(fluid_edges / max_edges * 100, 1), "%\n")
```

### Advanced Visualization Techniques

#### Dendrogram Visualization for Hierarchical Structure

```{r dendrogram_plot, eval=TRUE, fig.width=10, fig.height=8}
# Create a dendrogram showing the hierarchical clustering structure
# This provides a clear view of how categories are progressively aggregated
dendro_plot <- plot_moneca_dendrogram(
  seg,
  height_method = "uniform",          # Equal spacing between levels
  color_segments = TRUE,              # Color branches by final segments
  show_labels = TRUE,                 # Show category names
  label_size = 3.5,
  branch_width = 1.2,
  title = "MONECA Hierarchical Structure",
  subtitle = "Shows progressive aggregation from individual categories to segments",
  color_palette = "Set2",             # Colorblind-friendly palette
  theme_style = "minimal"
)

print(dendro_plot)
```

#### Quality Assessment Visualization

```{r quality_plots, eval=TRUE, fig.width=12, fig.height=10}
# Comprehensive segment quality analysis
quality_overview <- plot_segment_quality(
  seg,
  plot_type = "overview",
  level = 2,
  color_palette = "Set3",
  theme_style = "minimal",
  show_labels = TRUE,
  label_size = 3
)

print(quality_overview)

# Cohesion vs Size Analysis
cohesion_plot <- plot_segment_quality(
  seg,
  plot_type = "cohesion",
  level = 2,
  title = "Segment Quality Analysis: Cohesion vs Size",
  color_palette = "Dark2",
  show_labels = TRUE,
  label_size = 3.5
)

print(cohesion_plot)
```

### Custom Segment Naming for Enhanced Interpretation

MONECA includes enhanced segment naming functionality that allows you to provide meaningful, domain-specific labels for your mobility categories. This feature dramatically improves the interpretability of visualizations by replacing generic class names with substantive descriptions.

#### Basic Naming Strategies

The `segment_naming` parameter accepts several types of input:

```{r segment_naming_basic, eval=TRUE, fig.width=10, fig.height=8}
# Generate example data with meaningful class names
occupational_data <- generate_mobility_data(
  n_classes = 8,
  class_names = c("Executive", "Professional", "Manager", "Technical", 
                  "Skilled Worker", "Service Worker", "Clerical", "Manual Worker"),
  n_total = 8000,
  seed = 100
)

# Run MONECA analysis
occ_seg <- moneca(occupational_data, segment.levels = 3)

# Example 1: Auto strategy (default) - uses intelligent pattern recognition
auto_plot <- plot_moneca_ggraph(
  occ_seg,
  segment_naming = "auto",
  title = "Auto Naming Strategy: Pattern Recognition",
  node_color = "segment",
  show_segments = TRUE,
  color_palette = "Set2"
)

print(auto_plot)

# Example 2: Concatenation strategy - joins names with separator
concat_plot <- plot_moneca_ggraph(
  occ_seg,
  segment_naming = "concat",
  title = "Concatenation Strategy: Joined Names",
  node_color = "segment",
  show_segments = TRUE,
  color_palette = "Dark2"
)

print(concat_plot)
```

#### Advanced Custom Naming with Data Frames

The most powerful feature is the ability to provide custom labels using a data.frame:

```{r segment_naming_custom, eval=TRUE, fig.width=12, fig.height=10}
# Create custom segment labels that provide analytical insight
custom_labels <- data.frame(
  name = c("Executive", "Professional", "Manager", "Technical", 
           "Skilled Worker", "Service Worker", "Clerical", "Manual Worker"),
  segment_label = c(
    "Senior Leadership",      # Executive
    "Knowledge Workers",      # Professional  
    "Middle Management",      # Manager
    "Technical Specialists",  # Technical
    "Craft Workers",         # Skilled Worker
    "Service Industry",      # Service Worker
    "Administrative Staff",  # Clerical
    "Production Workers"     # Manual Worker
  ),
  stringsAsFactors = FALSE
)

print("Custom segment labels mapping:")
print(custom_labels)

# Use custom labels in main network plot
custom_plot <- plot_moneca_ggraph(
  occ_seg,
  segment_naming = custom_labels,
  title = "Custom Segment Naming: Occupational Class Structure",
  node_color = "segment",
  node_size = "total",
  show_segments = TRUE,
  segment_alpha = 0.2,
  color_palette = "Set3",
  show_labels = TRUE,
  label_size = 3.5
)

print(custom_plot)

# Show how this works across different plot types
# Ego network with custom naming
ego_custom <- plot_ego_ggraph(
  occ_seg,
  occupational_data,
  ego_id = 4,  # Technical worker
  segment_naming = custom_labels,
  title = "Technical Specialists: Mobility Patterns",
  highlight_color = "#E31A1C",
  flow_color = "viridis",
  min_weight = 20
)

print(ego_custom)
```

#### Partial Custom Naming

You can provide custom names for only some categories, with others using default strategies:

```{r segment_naming_partial, eval=TRUE, fig.width=10, fig.height=8}
# Partial custom naming - focus on key categories
key_positions <- data.frame(
  name = c("Executive", "Professional", "Manual Worker"),
  segment_label = c("Corporate Elite", "Professional Class", "Working Class"),
  stringsAsFactors = FALSE
)

partial_plot <- plot_moneca_ggraph(
  occ_seg,
  segment_naming = key_positions,
  title = "Partial Custom Naming: Highlighting Key Social Classes",
  node_color = "segment",
  node_size = "mobility",
  color_palette = "Spectral",
  show_segments = TRUE,
  segment_alpha = 0.15
)

print(partial_plot)

cat("\\nPartial custom naming allows focus on analytically important categories\\n")
cat("while maintaining readability for other positions.\\n")
```

#### Multi-Level Analysis with Custom Naming

Custom naming works seamlessly across hierarchical levels:

```{r segment_naming_multilevel, eval=TRUE, fig.width=12, fig.height=10}
# Multi-level visualization with consistent custom naming
multilevel_plots <- plot_stair_ggraph(
  occ_seg,
  levels = c(2, 3),
  segment_naming = custom_labels,
  color_palette = "Set2",
  node_size = "total",
  show_segments = TRUE,
  segment_alpha = 0.2,
  label_size = 3
)

print(multilevel_plots$`Level 2`)
print(multilevel_plots$`Level 3`)

# Show progression of segmentation with meaningful names
cat("\\nMulti-level segmentation progression with custom names:\\n")
for(level in 2:3) {
  n_segments <- length(occ_seg$segment.list[[level]])
  avg_size <- mean(sapply(occ_seg$segment.list[[level]], length))
  cat("Level", level, ":", n_segments, "occupational segments,", 
      "average", round(avg_size, 1), "classes per segment\\n")
}
```

#### Practical Applications

Custom segment naming is particularly valuable for:

1. **Occupational Mobility**: Use job titles or occupational categories
2. **Educational Analysis**: Replace generic levels with degree types
3. **Geographic Studies**: Use meaningful place names instead of codes
4. **Industry Analysis**: Employ sector names or industry classifications
5. **International Comparisons**: Apply country-specific terminology

```{r naming_applications, eval=FALSE}
# Example applications for different research contexts

# Educational mobility
education_labels <- data.frame(
  name = c("Level1", "Level2", "Level3", "Level4"),
  segment_label = c("No Degree", "High School", "Bachelor's", "Graduate"),
  stringsAsFactors = FALSE
)

# Geographic mobility  
geographic_labels <- data.frame(
  name = c("Region_A", "Region_B", "Region_C"),
  segment_label = c("Metropolitan", "Suburban", "Rural"),
  stringsAsFactors = FALSE
)

# Industry sectors
industry_labels <- data.frame(
  name = c("Sector1", "Sector2", "Sector3", "Sector4"),
  segment_label = c("Manufacturing", "Services", "Technology", "Healthcare"),
  stringsAsFactors = FALSE
)

# Use in analysis
plot_moneca_ggraph(seg, segment_naming = education_labels, 
                  title = "Educational Mobility Networks")
```

### Interpretation Guidelines for Visualizations

When interpreting MONECA network visualizations, consider these key elements:

#### Network Layout Interpretation
- **Node Position**: Reflects mathematical similarity in mobility patterns
- **Edge Thickness**: Proportional to relative risk of mobility between positions  
- **Cluster Proximity**: Positions with similar mobility profiles appear closer together
- **Segment Boundaries**: Convex hulls show positions with high internal mobility

#### Color and Size Encoding
- **Node Colors**: Represent segment membership at the specified hierarchical level
- **Node Sizes**: Can represent total mobility volume, mobility rates, or custom metrics
- **Edge Colors**: Often represent flow direction or connection strength
- **Transparency**: Used to manage visual complexity while preserving information

#### Custom Naming Benefits
- **Enhanced Readability**: Meaningful labels improve immediate comprehension
- **Domain Relevance**: Context-specific terminology aids interpretation
- **Professional Presentation**: Polished visualizations for publications and reports
- **Analytical Focus**: Highlight theoretically important distinctions

#### Accessibility Features
All plots include several accessibility enhancements:

```{r accessibility_features, eval=FALSE}
# Example showing all accessibility features
accessible_plot <- plot_moneca_ggraph(
  seg,
  # Colorblind-safe palettes
  color_palette = "Set2",           # For categorical: "Set2", "Dark2", "Paired"
                                    # For continuous: "viridis", "plasma", "inferno"
  
  # High contrast settings
  node_alpha = 0.85,               # Strong node visibility
  edge_alpha = 0.6,                # Balanced edge visibility
  edge_color = "grey30",           # Dark edges for contrast
  
  # Redundant encoding (color + size + position)
  node_color = "segment",          # Color by segment
  node_size = "total",             # Size by mobility volume
  
  # Clear labeling
  show_labels = TRUE,              # Display node names
  label_size = 3.5,                # Readable text size
  show_segments = TRUE,            # Segment boundaries
  
  # Informative titles
  title = "Descriptive Title"      # Clear context
)
```

## Analytical Functions

### Segment Quality Assessment

```{r quality_assessment}
# Assess the quality of segmentation for 30-class system
level2_matrix <- seg$mat.list[[2]]
cat("Level 2 aggregated matrix dimensions:", dim(level2_matrix), "\n")
print("Level 2 mobility matrix (aggregated):")
print(level2_matrix)

# Calculate internal mobility rates for each segment
# Use actual number of segments from segment.list instead of matrix dimensions
actual_n_segments <- length(seg$segment.list[[2]])
n_segments <- nrow(level2_matrix) - 1

# Ensure we use the correct number of segments (the smaller of the two)
active_segments <- min(actual_n_segments, n_segments)

internal_mobility <- diag(level2_matrix[1:active_segments, 1:active_segments])
total_mobility <- level2_matrix[1:active_segments, ncol(level2_matrix)]
immobility_rates <- internal_mobility / total_mobility

cat("\nImmobility rates by segment at Level 2:\n")
segment_summary <- data.frame(
  Segment = paste("Segment", 1:active_segments),
  Size = sapply(seg$segment.list[[2]], length)[1:active_segments],
  Total_Population = total_mobility,
  Internal_Mobility = internal_mobility,
  Immobility_Rate = round(immobility_rates * 100, 1)
)
print(segment_summary)

# Calculate overall segmentation quality metrics
overall_internal <- sum(internal_mobility)
overall_total <- sum(level2_matrix[1:active_segments, 1:active_segments])
overall_immobility_rate <- overall_internal / overall_total

cat("\nOverall Level 2 segmentation quality:\n")
cat("Total segments:", active_segments, "\n")
cat("Average segment size:", round(mean(segment_summary$Size), 1), "classes\n")
cat("Overall internal mobility rate:", round(overall_immobility_rate * 100, 1), "%\n")

# Compare to Level 1 (original classes)
level1_internal <- sum(diag(basic_data[1:30, 1:30]))
level1_total <- sum(basic_data[1:30, 1:30])
level1_rate <- level1_internal / level1_total

cat("Level 1 internal mobility rate:", round(level1_rate * 100, 1), "%\n")
cat("Improvement in clustering:", round((overall_immobility_rate - level1_rate) * 100, 1), "percentage points\n")
```

### Edge Analysis

```{r edge_analysis}
# Examine edge weights between classes (Level 1) for 30-class system
edges <- segment.edges(seg, level = 1)
cat("Edge weights matrix dimensions:", dim(edges), "\n")
cat("Number of significant edges (RR > 1):", sum(!is.na(edges) & edges > 1), "\n")

# Show subset of edge weights matrix (first 10x10)
cat("\nEdge weights matrix (first 10x10 subset):\n")
edges_subset <- edges[1:10, 1:10]
print(round(edges_subset, 2))

# Focus on strongest connections
strong_edges <- edges
strong_edges[strong_edges < 2] <- NA
strong_connections <- sum(!is.na(strong_edges))
cat("\nNumber of strong connections (relative risk > 2):", strong_connections, "\n")

# Show distribution of edge weights
all_edges <- as.vector(edges)
valid_edges <- all_edges[!is.na(all_edges) & all_edges > 1]
cat("\nEdge weight distribution (RR > 1):\n")
cat("Min:", round(min(valid_edges), 2), "\n")
cat("Median:", round(median(valid_edges), 2), "\n")
cat("Mean:", round(mean(valid_edges), 2), "\n")
cat("Max:", round(max(valid_edges), 2), "\n")
cat("95th percentile:", round(quantile(valid_edges, 0.95), 2), "\n")

# Show strongest connections in the network
if(length(valid_edges) > 0) {
  threshold_95 <- quantile(valid_edges, 0.95)
  strongest_indices <- which(edges > threshold_95, arr.ind = TRUE)
  if(nrow(strongest_indices) > 0) {
    cat("\nStrongest connections (top 5% of edge weights):\n")
    for(i in 1:min(10, nrow(strongest_indices))) {
      row <- strongest_indices[i, 1]
      col <- strongest_indices[i, 2]
      weight <- edges[row, col]
      cat("Class", sprintf("%02d", row), "-> Class", sprintf("%02d", col), 
          ": RR =", round(weight, 2), "\n")
    }
  }
}
```

## Working with Real Data

When working with your own mobility data, ensure it follows the MONECA format:

### Data Format Requirements

```{r data_format}
# Your data should be a matrix with:
# - Rows: origin positions
# - Columns: destination positions  
# - Last row: column totals
# - Last column: row totals
# - Bottom-right cell: grand total

# Example of properly formatted data structure (showing 5x5 for clarity):
example_structure <- matrix(c(
  180, 25, 15, 8, 2, 230,    # Origin 1: mostly immobile with some movement
  20, 190, 30, 12, 3, 255,   # Origin 2: similar pattern
  12, 28, 175, 25, 10, 250,  # Origin 3: high diagonal mobility
  6, 15, 20, 160, 19, 220,   # Origin 4: concentrated mobility
  3, 8, 12, 22, 145, 190,    # Origin 5: strong immobility
  221, 266, 252, 227, 179, 1145  # Column totals and grand total
), nrow = 6, ncol = 6)

rownames(example_structure) <- c("Class_A", "Class_B", "Class_C", "Class_D", "Class_E", "Total")
colnames(example_structure) <- c("Class_A", "Class_B", "Class_C", "Class_D", "Class_E", "Total")

print("Properly formatted mobility matrix (5x5 example):")
print(example_structure)

cat("\nKey features of mobility matrix format:\n")
cat("- Matrix size: (n+1) x (n+1) where n is number of classes\n")
cat("- Diagonal: immobility (people staying in same class)\n")
cat("- Off-diagonal: mobility between classes\n")
cat("- Row totals: total outflow from each origin class\n")
cat("- Column totals: total inflow to each destination class\n")
cat("- Grand total: total population in the mobility table\n")
```

### Data Validation

```{r data_validation}
# Check if your data is properly formatted
validate_mobility_matrix <- function(mat) {
  n <- nrow(mat) - 1
  
  # Check row totals
  calculated_row_totals <- rowSums(mat[1:n, 1:n])
  actual_row_totals <- mat[1:n, n + 1]
  
  # Check column totals  
  calculated_col_totals <- colSums(mat[1:n, 1:n])
  actual_col_totals <- mat[n + 1, 1:n]
  
  # Check grand total
  calculated_grand_total <- sum(mat[1:n, 1:n])
  actual_grand_total <- mat[n + 1, n + 1]
  
  # Additional validation checks for larger matrices
  validation_results <- list(
    matrix_size = paste(dim(mat), collapse = " x "),
    n_classes = n,
    row_totals_match = all.equal(calculated_row_totals, actual_row_totals),
    col_totals_match = all.equal(calculated_col_totals, actual_col_totals),
    grand_total_matches = all.equal(calculated_grand_total, actual_grand_total),
    has_negative_values = any(mat < 0),
    total_population = actual_grand_total,
    sparsity = round(sum(mat[1:n, 1:n] == 0) / (n^2) * 100, 1)
  )
  
  return(validation_results)
}

# Validate our 5x5 example
cat("Validation of 5x5 example matrix:\n")
validation_small <- validate_mobility_matrix(example_structure)
print(validation_small)

# Validate our large 30x30 synthetic data
cat("\nValidation of 30x30 synthetic mobility matrix:\n")
validation_large <- validate_mobility_matrix(basic_data)
print(validation_large)

# Show validation function usage for user data
cat("\nTo validate your own data:\n")
cat("validation_results <- validate_mobility_matrix(your_matrix)\n")
cat("print(validation_results)\n")
```

## Best Practices and Tips

### Choosing Parameters

1. **Number of levels**: Start with 3-4 levels, adjust based on your data size
2. **Cut-off values**: Default (1.0) works well for relative risk; adjust for sensitivity
3. **Small cell reduction**: Use to handle sparse data in large matrices

### Visualization Best Practices

#### Color Palette Selection
Choose palettes based on your data type and accessibility needs:

```{r palette_examples, eval=FALSE}
# For categorical data (segments)
plot_moneca_ggraph(seg, color_palette = "Set2")    # Colorblind-safe qualitative
plot_moneca_ggraph(seg, color_palette = "Dark2")   # High contrast qualitative

# For continuous data (mobility rates)
plot_moneca_ggraph(seg, node_color = "mobility", color_palette = "viridis")  # Perceptually uniform
plot_moneca_ggraph(seg, node_color = "mobility", color_palette = "plasma")   # Alternative continuous

# For comparing different systems
plot_moneca_ggraph(rigid_seg, color_palette = "Oranges")   # Sequential for one system
plot_moneca_ggraph(fluid_seg, color_palette = "Purples")   # Different sequential for comparison
```

#### Layout Algorithm Selection
Different layouts work better for different network characteristics:

```{r layout_examples, eval=FALSE}
# Force-directed layouts
plot_moneca_ggraph(seg, layout = "fr")      # Fruchterman-Reingold (balanced)
plot_moneca_ggraph(seg, layout = "kk")      # Kamada-Kawai (minimize edge crossings)

# Optimization-based layouts
plot_moneca_ggraph(seg, layout = "stress")  # Stress majorization (clean, clear)
plot_moneca_ggraph(seg, layout = "mds")     # Multidimensional scaling

# For consistent comparisons
consistent_layout <- layout.matrix(seg)     # MONECA's specialized layout
plot_moneca_ggraph(seg, layout = consistent_layout)
```

#### Node and Edge Styling
Optimize visual elements for clarity and accessibility:

```{r styling_examples, eval=FALSE}
# High contrast for presentations
plot_moneca_ggraph(seg,
  node_alpha = 0.9,        # Strong nodes
  edge_alpha = 0.4,        # Subtle edges
  edge_color = "grey20",   # Dark edges
  label_size = 4           # Large labels
)

# Detailed analysis version
plot_moneca_ggraph(seg,
  node_size = "mobility",  # Size by analytical variable
  edge_width = "weight",   # Width by connection strength
  show_segments = TRUE,    # Show cluster boundaries
  segment_alpha = 0.15     # Subtle boundaries
)
```

### Interpretation Guidelines

1. **Segments represent groups** with high internal mobility
2. **Hierarchical structure** shows nested clustering at different scales  
3. **Edge weights** indicate relative risk compared to independence
4. **Layout algorithms** can emphasize different network properties

## Auto-Tuning Functionality

The moneca package includes comprehensive auto-tuning capabilities that automatically optimize the `small.cell.reduction` parameter for improved clustering results. This feature eliminates manual parameter selection and can significantly improve clustering quality.

### Why Auto-Tuning?

The `small.cell.reduction` parameter controls how small mobility cells are handled during clustering. Finding the optimal value manually can be:

- **Time-consuming**: Requires testing multiple values
- **Subjective**: Different users might choose different values
- **Data-dependent**: Optimal values vary by dataset characteristics
- **Quality-affecting**: Poor parameter choice reduces clustering performance

### Auto-Tuning Methods

```{r auto_tuning_demo, eval=TRUE, fig.width=12, fig.height=8}
# Generate test data for auto-tuning demonstration
set.seed(456)
mobility_data <- generate_mobility_data(
  n_classes = 6,
  immobility_strength = 0.7,
  class_clustering = 0.8,
  noise_level = 0.1,
  class_names = paste0("Class_", LETTERS[1:6])
)

print("Original mobility matrix:")
print(round(mobility_data, 2))

# Method 1: Stability-based tuning (default)
cat("\n=== Stability-Based Auto-Tuning ===\n")
seg_auto_stability <- moneca(
  mobility_data,
  segment.levels = 2,
  auto_tune = TRUE,
  tune_method = "stability",
  tune_verbose = TRUE
)

# Method 2: Quality-based tuning  
cat("\n=== Quality-Based Auto-Tuning ===\n")
seg_auto_quality <- moneca(
  mobility_data,
  segment.levels = 2,
  auto_tune = TRUE,
  tune_method = "quality",
  tune_verbose = TRUE
)

# Method 3: Performance-balanced tuning
cat("\n=== Performance-Balanced Auto-Tuning ===\n")
seg_auto_performance <- moneca(
  mobility_data,
  segment.levels = 2,
  auto_tune = TRUE,
  tune_method = "performance",
  tune_verbose = TRUE
)

# Compare with manual parameter selection
seg_manual <- moneca(mobility_data, segment.levels = 2, small.cell.reduction = 5)
```

### Comparison: Manual vs Auto-Tuned Results

```{r auto_tuning_comparison, eval=TRUE, fig.width=15, fig.height=12}
# Create comparison plots
library(gridExtra)

# Manual parameter plot
manual_plot <- plot_moneca_ggraph(
  seg_manual,
  title = "Manual Parameter (small.cell.reduction = 5)",
  node_color = "segment",
  node_size = "total",
  show_segments = TRUE,
  color_palette = "Set1"
)

# Auto-tuned stability plot  
stability_plot <- plot_moneca_ggraph(
  seg_auto_stability,
  title = paste0("Auto-Tuned (Stability Method)\nOptimal parameter: ", 
                attr(seg_auto_stability, "auto_tune_result")$best_parameter),
  node_color = "segment", 
  node_size = "total",
  show_segments = TRUE,
  color_palette = "Set2"
)

# Auto-tuned quality plot
quality_plot <- plot_moneca_ggraph(
  seg_auto_quality,
  title = paste0("Auto-Tuned (Quality Method)\nOptimal parameter: ",
                attr(seg_auto_quality, "auto_tune_result")$best_parameter),
  node_color = "segment",
  node_size = "total", 
  show_segments = TRUE,
  color_palette = "Set3"
)

# Performance-balanced plot
performance_plot <- plot_moneca_ggraph(
  seg_auto_performance,
  title = paste0("Auto-Tuned (Performance Method)\nOptimal parameter: ",
                attr(seg_auto_performance, "auto_tune_result")$best_parameter),
  node_color = "segment",
  node_size = "total",
  show_segments = TRUE, 
  color_palette = "Dark2"
)

# Arrange plots
grid.arrange(manual_plot, stability_plot, quality_plot, performance_plot, 
             ncol = 2, nrow = 2)
```

### Advanced Auto-Tuning Methods

```{r advanced_auto_tuning, eval=FALSE}
# Pareto optimization - balances multiple objectives
cat("\n=== Pareto Multi-Objective Optimization ===\n")
seg_pareto <- moneca(
  mobility_data,
  segment.levels = 2,
  auto_tune = TRUE,
  tune_method = "pareto",
  tune_verbose = TRUE
)

print("Pareto optimization results:")
pareto_result <- attr(seg_pareto, "auto_tune_result")
if (!is.null(pareto_result$pareto_front)) {
  print(head(pareto_result$pareto_front))
}

# Cross-validation based tuning
cat("\n=== Cross-Validation Based Tuning ===\n") 
seg_cv <- moneca(
  mobility_data,
  segment.levels = 2,
  auto_tune = TRUE,
  tune_method = "cross_validation",
  tune_verbose = TRUE
)
```

### Auto-Tuning Parameters Reference

| Parameter | Description | Default | Notes |
|-----------|-------------|---------|-------|
| `auto_tune` | Enable auto-tuning | `FALSE` | Set to `TRUE` to activate |
| `tune_method` | Tuning method | `"stability"` | See methods below |
| `tune_verbose` | Show detailed output | `FALSE` | Set to `TRUE` for progress info |

### Auto-Tuning Methods Explained

#### 1. Stability Method (`"stability"`)
- **Best for**: General purpose, robust clustering
- **How it works**: Bootstrap sampling to assess consistency
- **Advantages**: Reliable, works well with most datasets
- **Use when**: You want robust, generalizable results

#### 2. Quality Method (`"quality"`)  
- **Best for**: Maximizing clustering performance
- **How it works**: Optimizes silhouette score and modularity
- **Advantages**: Highest clustering quality
- **Use when**: Quality is more important than speed

#### 3. Performance Method (`"performance"`)
- **Best for**: Balancing quality and computational efficiency
- **How it works**: Weighted combination of quality and speed metrics
- **Advantages**: Good compromise for large datasets
- **Use when**: You need reasonable results quickly

#### 4. Pareto Method (`"pareto"`)
- **Best for**: Understanding trade-offs between objectives
- **How it works**: Multi-objective optimization with Pareto frontier
- **Advantages**: Shows all optimal trade-offs
- **Use when**: You want to explore different quality/speed combinations

#### 5. Cross-Validation Method (`"cross_validation"`)
- **Best for**: Conservative parameter selection
- **How it works**: K-fold cross-validation with stability assessment
- **Advantages**: Reduces overfitting risk
- **Use when**: Dataset is small or you're concerned about overfitting

### Auto-Tuning Visualization

```{r auto_tuning_visualization, eval=TRUE, fig.width=12, fig.height=10}
# The auto-tuning process generates diagnostic information
tuning_result <- attr(seg_auto_stability, "auto_tune_result")

if (!is.null(tuning_result)) {
  cat("Auto-tuning summary:\n")
  cat("Method:", tuning_result$method, "\n")
  cat("Best parameter:", tuning_result$best_parameter, "\n")
  cat("Best score:", round(tuning_result$best_score, 4), "\n")
  cat("Evaluation time:", round(tuning_result$evaluation_time, 2), "seconds\n")
  
  # Plot tuning results if available
  if (!is.null(tuning_result$all_results)) {
    results_df <- as.data.frame(tuning_result$all_results)
    
    tuning_plot <- ggplot(results_df, aes(x = parameter, y = score)) +
      geom_line(color = "steelblue", size = 1.2) +
      geom_point(color = "steelblue", size = 3) +
      geom_point(data = results_df[which.max(results_df$score), ],
                 color = "red", size = 5, shape = 16) +
      geom_vline(xintercept = tuning_result$best_parameter, 
                 linetype = "dashed", color = "red", alpha = 0.7) +
      labs(title = "Auto-Tuning Parameter Search Results",
           subtitle = paste("Best parameter:", tuning_result$best_parameter, 
                           "| Score:", round(tuning_result$best_score, 4)),
           x = "Small Cell Reduction Parameter",
           y = "Stability Score") +
      theme_minimal() +
      theme(plot.title = element_text(size = 14, hjust = 0.5),
            plot.subtitle = element_text(size = 12, hjust = 0.5))
    
    print(tuning_plot)
  }
}
```

### Best Practices for Auto-Tuning

1. **Start with stability method**: It provides reliable results for most datasets
2. **Use quality method for publication**: When clustering quality is paramount
3. **Consider performance method for large datasets**: Balances quality and speed
4. **Set seed for reproducibility**: Ensures consistent results across runs
5. **Check auto-tuning results**: Examine the selected parameter and scores
6. **Validate with multiple methods**: Compare results across different tuning approaches

### When to Use Manual Parameters

Auto-tuning is not always necessary or appropriate:

- **Known optimal parameters**: If you already know good parameters for your domain
- **Computational constraints**: When auto-tuning would be too slow
- **Specific requirements**: When you need exact control over the clustering process
- **Legacy compatibility**: When reproducing previous analyses exactly

### Performance Considerations

1. **Large matrices** (>50x50) may require increased computation time
2. **Progress bars** show optimization progress for large datasets  
3. **Memory usage** grows with number of levels and matrix size
4. **Auto-tuning adds overhead**: Plan for 2-10x longer computation time
5. **Performance tuning**: Use `tune_method = "performance"` for faster results on large datasets

## Conclusion

MONECA provides a powerful framework for analyzing social mobility through network-based clustering. The combination of:

- Flexible clustering algorithms
- Modern visualization capabilities  
- Hierarchical segmentation
- Quality assessment tools

Makes it suitable for exploring mobility patterns in diverse social contexts.

### Further Reading

- Original MONECA methodology papers
- Network analysis in social mobility research
- Graph-theoretic approaches to social structure

### Getting Help

- Use `?function_name` for detailed function documentation
- Check the package website for updates and examples
- Report issues on the GitHub repository

```{r session_info}
# Session information for reproducibility
sessionInfo()
```