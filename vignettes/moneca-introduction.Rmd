---
title: "Introduction to moneca: Mobility Network Clustering Analysis"
author: "Giampaolo Montaletti"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
    fig_width: 8
    fig_height: 6
vignette: >
  %\VignetteIndexEntry{Introduction to moneca: Mobility Network Clustering Analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "figures/",
  warning = FALSE,
  message = FALSE,
  fig.width = 10,
  fig.height = 8,
  dpi = 150,
  out.width = "100%"
)

# Check if required packages are available
required_packages <- c("ggplot2", "ggraph", "igraph", "dplyr", "tidygraph", "viridis", "RColorBrewer")
missing_packages <- required_packages[!sapply(required_packages, requireNamespace, quietly = TRUE)]

if (length(missing_packages) > 0) {
  knitr::opts_chunk$set(eval = FALSE)
  message("Some required packages are missing: ", paste(missing_packages, collapse = ", "))
  message("Code examples will not be evaluated.")
}
```

## Introduction

moneca (Mobility Network Clustering Analysis) is an R package that analyzes social mobility patterns through graph-theoretic approaches. The package creates weighted networks from mobility tables and uses cliques to identify discrete and nested clusters of positions with high internal mobility.

### About This Vignette

This vignette was written by **Giampaolo Montaletti** as part of the comprehensive modernization of the moneca package (2024). It provides a complete guide to using the modern features and capabilities of the package, including the new visualization system, synthetic data generation, and enhanced analysis tools.

### Package Background

The **moneca** package (lowercase) is a complete rewrite and modernization of the original MONECA package. While it implements the clustering algorithm originally developed by Touboel & Larsen (2017), the current package features entirely new code for visualization, testing, data generation, and documentation authored by Giampaolo Montaletti.

### Key Features

- **Network-based clustering** of mobility tables
- **Hierarchical segmentation** at multiple levels
- **Modern visualization** with ggplot2 and ggraph
- **Quality metrics** for assessing segmentation performance
- **Synthetic data generation** for testing and demonstrations

## Basic Concepts

Social mobility can be represented as a network where:

- **Nodes** represent social positions (occupations, classes, etc.)
- **Edges** represent mobility flows between positions
- **Edge weights** represent the strength of mobility connections
- **Clusters** represent groups of positions with high internal mobility

MONECA identifies these clusters by:

1. Converting mobility tables to relative risk matrices
2. Finding cliques in the weighted network
3. Iteratively aggregating positions into segments
4. Creating hierarchical segmentation levels

## Installation and Setup

```{r installation, eval=FALSE}
# Install from GitHub
devtools::install_github("gmontaletti/moneca")

# Load the package
library(moneca)

# Load additional packages for visualization
library(ggplot2)
library(ggraph)
```

```{r load_package, echo=FALSE}
# For vignette building
library(moneca)
```

## Working with Synthetic Data

MONECA includes functions to generate synthetic mobility data for demonstrations and testing.

### Creating Basic Synthetic Data

```{r synthetic_basic}
# Generate a simple 5-class mobility table
basic_data <- generate_mobility_data(
  n_classes = 5,
  n_total = 2000,
  immobility_strength = 0.7,
  class_clustering = 0.2,
  class_names = c("Upper", "Upper-Mid", "Middle", "Lower-Mid", "Working"),
  seed = 42
)

# View the structure
print(basic_data)
```

The mobility matrix shows:
- **Rows**: Origin classes (where people start)
- **Columns**: Destination classes (where people end up)
- **Last row/column**: Marginal totals
- **Diagonal**: Immobility (staying in same class)

### Creating Different Mobility Scenarios

```{r synthetic_scenarios}
# Get multiple example datasets
examples <- generate_example_datasets()
names(examples)

# Examine the rigid class system
print("Rigid class system:")
print(examples$rigid)

# Examine the fluid (highly mobile) system
print("Fluid mobility system:")
print(examples$fluid)
```

## Running MONECA Analysis

### Basic Analysis

```{r basic_analysis}
# Run MONECA on the basic dataset
seg <- moneca(basic_data, segment.levels = 3)

# View the results
print(seg)
```

The MONECA object contains:
- `segment.list`: Hierarchical clusters for each level
- `mat.list`: Aggregated mobility matrices for each level

### Understanding the Results

```{r understand_results}
# View segment membership
membership <- segment.membership(seg)
print(membership)

# View the aggregated matrix for level 2
print("Level 2 aggregated matrix:")
print(seg$mat.list[[2]])
```

## Modern Visualization with ggraph

MONECA now includes modern visualization functions using ggplot2 and ggraph, designed with accessibility and clarity as primary concerns.

### Visualization Design Principles

All MONECA plotting functions follow evidence-based design principles for maximum accessibility and clarity:

1. **Colorblind Accessibility**: Uses viridis, plasma, and ColorBrewer palettes that are perceptually uniform and distinguishable for all types of color vision
2. **High Contrast**: Maintains WCAG AA contrast ratios for text and visual elements
3. **Redundant Encoding**: Uses both color and other visual properties (size, shape, position) to encode information
4. **Clear Visual Hierarchy**: Guides attention through strategic use of size, transparency, and positioning
5. **Minimal Cognitive Load**: Reduces visual clutter while maintaining analytical depth

```{r accessibility_demo, eval=FALSE}
# Example of accessibility-focused plotting
plot_moneca_ggraph(
  seg,
  color_palette = "Set2",       # Colorblind-safe qualitative palette
  node_alpha = 0.85,            # High contrast
  edge_alpha = 0.6,             # Balanced visibility
  show_segments = TRUE,         # Visual grouping
  segment_alpha = 0.2,          # Subtle boundaries
  label_size = 3.5              # Readable text
)

# For continuous variables, use viridis family
plot_moneca_ggraph(
  seg,
  node_color = "mobility",      # Color by mobility rates
  color_palette = "viridis",    # Colorblind-safe continuous scale
  node_alpha = 0.85,
  edge_alpha = 0.6
)
```

### Basic Network Plot with Colorblind-Friendly Design

```{r plot_basic, eval=TRUE, fig.width=8, fig.height=6}
# Create a basic network plot with improved accessibility
# Using viridis color palette (colorblind-friendly) and optimized layout
p1 <- plot_moneca_ggraph(
  seg,
  title = "Social Mobility Network: Hierarchical Segmentation",
  subtitle = "Node colors represent segment membership, sizes show total mobility",
  layout = "stress",  # Better layout for clear network structure
  node_color = "segment",
  node_size = "total",
  color_palette = "Set2",  # Colorblind-friendly palette
  node_alpha = 0.85,
  edge_alpha = 0.7,
  show_segments = TRUE,
  segment_alpha = 0.2,
  label_size = 3.5
)

print(p1)
```

### Advanced Network Visualization with Clear Segment Boundaries

```{r plot_custom, eval=TRUE, fig.width=10, fig.height=8}
# Create an advanced plot emphasizing segment structure and accessibility
p2 <- plot_moneca_ggraph(
  seg,
  layout = "fr",  # Force-directed layout for balanced positioning
  node_color = "segment",
  node_size = "mobility",  # Size by mobility rate for analytical insight
  edge_width = "weight",
  color_palette = "Dark2",  # High-contrast ColorBrewer palette
  edge_color = "grey30",  # Darker edges for better visibility
  theme_style = "minimal",
  title = "Advanced MONECA Network Analysis",
  subtitle = "Segments highlighted with convex hulls, node sizes show mobility rates",
  show_labels = TRUE,
  label_size = 4,
  show_segments = TRUE,
  segment_alpha = 0.15,
  node_alpha = 0.9,
  edge_alpha = 0.6
)

print(p2)
```

### Ego Network Analysis: Focus on Individual Position Dynamics

Ego networks reveal mobility patterns from a single focal position, showing both incoming and outgoing flows:

```{r ego_plot, eval=TRUE, fig.width=9, fig.height=7}
# Create ego network for the middle class (position 3) with enhanced accessibility
p3 <- plot_ego_ggraph(
  seg,
  basic_data,
  ego_id = 3,
  layout = "stress",  # Stress layout for cleaner ego networks
  title = "Ego Network Analysis: Middle Class Mobility Patterns",
  subtitle = "Red nodes: focal position and same-segment connections; Flow width indicates volume",
  highlight_color = "#D55E00",  # Colorblind-safe orange-red
  flow_color = "plasma",  # Perceptually uniform color scale
  node_size_range = c(3, 12),
  edge_width_range = c(0.5, 4),
  min_weight = 5  # Filter weak connections for clarity
)

print(p3)
```

### Multi-Level Segmentation: Hierarchical Structure Visualization

```{r stair_plot, eval=TRUE, fig.width=12, fig.height=10}
# Create stair plots showing progressive segmentation with consistent layout
# Using consistent positioning to track segment evolution across levels
stair_plots <- plot_stair_ggraph(
  seg, 
  levels = 2:3,
  layout = NULL,  # Use consistent layout.matrix for position stability
  segment_naming = "auto",
  color_palette = "Set2",  # Colorblind-friendly qualitative palette
  node_size = "total",
  edge_alpha = 0.6,
  node_alpha = 0.85,
  segment_alpha = 0.2,
  label_size = 3.5
)

# Display individual plots with improved spacing
print(stair_plots$`Level 2`)
print(stair_plots$`Level 3`)
```

## Advanced Analysis Examples

### Comparing Different Mobility Regimes

```{r compare_regimes}
# Analyze the rigid class system
rigid_seg <- moneca(examples$rigid, segment.levels = 3)

# Analyze the fluid mobility system  
fluid_seg <- moneca(examples$fluid, segment.levels = 3)

# Compare segment memberships
print("Rigid system segments:")
print(segment.membership(rigid_seg))

print("Fluid system segments:")
print(segment.membership(fluid_seg))
```

### Comparing Mobility Regimes: Accessibility-Focused Visualizations

```{r compare_plots, eval=TRUE, fig.width=12, fig.height=6}
# Compare rigid vs fluid systems using colorblind-safe palettes and clear differentiation

# Plot rigid system - emphasis on strong boundaries
p_rigid <- plot_moneca_ggraph(
  rigid_seg,
  title = "Rigid Class System: Strong Internal Cohesion",
  subtitle = "High immobility rates create distinct, well-separated segments",
  layout = "stress",
  node_color = "segment",
  node_size = "total",
  color_palette = "Oranges",  # Sequential palette for rigid structure
  edge_color = "grey20",
  show_segments = TRUE,
  segment_alpha = 0.25,
  node_alpha = 0.9,
  edge_alpha = 0.5,
  label_size = 3.5
)

# Plot fluid system - emphasis on connectivity
p_fluid <- plot_moneca_ggraph(
  fluid_seg,
  title = "Fluid Mobility System: High Inter-Segment Flow",
  subtitle = "Strong cross-segment mobility creates overlapping, less distinct boundaries",
  layout = "stress",
  node_color = "segment",
  node_size = "mobility",  # Size by mobility rate to show fluidity
  color_palette = "Purples",  # Different sequential palette for contrast
  edge_color = "grey30",
  show_segments = TRUE,
  segment_alpha = 0.15,  # Lower alpha for fluid boundaries
  node_alpha = 0.85,
  edge_alpha = 0.7,  # Higher edge alpha to show connectivity
  label_size = 3.5
)

print(p_rigid)
print(p_fluid)
```

### Advanced Visualization Techniques

#### Dendrogram Visualization for Hierarchical Structure

```{r dendrogram_plot, eval=TRUE, fig.width=10, fig.height=8}
# Create a dendrogram showing the hierarchical clustering structure
# This provides a clear view of how categories are progressively aggregated
dendro_plot <- plot_moneca_dendrogram(
  seg,
  height_method = "uniform",          # Equal spacing between levels
  color_segments = TRUE,              # Color branches by final segments
  show_labels = TRUE,                 # Show category names
  label_size = 3.5,
  branch_width = 1.2,
  title = "MONECA Hierarchical Structure",
  subtitle = "Shows progressive aggregation from individual categories to segments",
  color_palette = "Set2",             # Colorblind-friendly palette
  theme_style = "minimal"
)

print(dendro_plot)
```

#### Quality Assessment Visualization

```{r quality_plots, eval=TRUE, fig.width=12, fig.height=10}
# Comprehensive segment quality analysis
quality_overview <- plot_segment_quality(
  seg,
  plot_type = "overview",
  level = 2,
  color_palette = "Set3",
  theme_style = "minimal",
  show_labels = TRUE,
  label_size = 3
)

print(quality_overview)

# Cohesion vs Size Analysis
cohesion_plot <- plot_segment_quality(
  seg,
  plot_type = "cohesion",
  level = 2,
  title = "Segment Quality Analysis: Cohesion vs Size",
  color_palette = "Dark2",
  show_labels = TRUE,
  label_size = 3.5
)

print(cohesion_plot)
```

### Interpretation Guidelines for Visualizations

When interpreting MONECA network visualizations, consider these key elements:

#### Network Layout Interpretation
- **Node Position**: Reflects mathematical similarity in mobility patterns
- **Edge Thickness**: Proportional to relative risk of mobility between positions  
- **Cluster Proximity**: Positions with similar mobility profiles appear closer together
- **Segment Boundaries**: Convex hulls show positions with high internal mobility

#### Color and Size Encoding
- **Node Colors**: Represent segment membership at the specified hierarchical level
- **Node Sizes**: Can represent total mobility volume, mobility rates, or custom metrics
- **Edge Colors**: Often represent flow direction or connection strength
- **Transparency**: Used to manage visual complexity while preserving information

#### Accessibility Features
All plots include several accessibility enhancements:

```{r accessibility_features, eval=FALSE}
# Example showing all accessibility features
accessible_plot <- plot_moneca_ggraph(
  seg,
  # Colorblind-safe palettes
  color_palette = "Set2",           # For categorical: "Set2", "Dark2", "Paired"
                                    # For continuous: "viridis", "plasma", "inferno"
  
  # High contrast settings
  node_alpha = 0.85,               # Strong node visibility
  edge_alpha = 0.6,                # Balanced edge visibility
  edge_color = "grey30",           # Dark edges for contrast
  
  # Redundant encoding (color + size + position)
  node_color = "segment",          # Color by segment
  node_size = "total",             # Size by mobility volume
  
  # Clear labeling
  show_labels = TRUE,              # Display node names
  label_size = 3.5,                # Readable text size
  show_segments = TRUE,            # Segment boundaries
  
  # Informative titles
  title = "Descriptive Title",     # Clear context
  subtitle = "Detailed explanation" # Additional information
)
```

## Analytical Functions

### Segment Quality Assessment

```{r quality_assessment}
# Assess the quality of segmentation
# (Note: this function may need to be implemented)
# quality_metrics <- segment.quality(seg)
# print(quality_metrics)

# Alternative: examine within vs. between segment mobility
level2_matrix <- seg$mat.list[[2]]
print("Level 2 mobility matrix (aggregated):")
print(level2_matrix)

# Calculate internal mobility rates
# Exclude the totals row and column to get the core mobility matrix
n_segments <- nrow(level2_matrix) - 1
internal_mobility <- diag(level2_matrix[1:n_segments, 1:n_segments])
total_mobility <- level2_matrix[1:n_segments, ncol(level2_matrix)]
immobility_rates <- internal_mobility / total_mobility

print("Immobility rates by segment:")
print(immobility_rates)
```

### Edge Analysis

```{r edge_analysis}
# Examine edge weights between segments
edges <- segment.edges(seg, level = 1)
print("Edge weights matrix:")
print(edges)

# Focus on strongest connections
strong_edges <- edges
strong_edges[strong_edges < 2] <- NA
print("Strong connections (relative risk > 2):")
print(strong_edges)
```

## Working with Real Data

When working with your own mobility data, ensure it follows the MONECA format:

### Data Format Requirements

```{r data_format}
# Your data should be a matrix with:
# - Rows: origin positions
# - Columns: destination positions  
# - Last row: column totals
# - Last column: row totals
# - Bottom-right cell: grand total

# Example of properly formatted data structure:
example_structure <- matrix(c(
  100, 20, 10, 130,  # Origin 1: 100 stay, 20 to pos 2, 10 to pos 3, total 130
  15, 200, 25, 240,  # Origin 2: 15 to pos 1, 200 stay, 25 to pos 3, total 240  
  10, 30, 180, 220,  # Origin 3: 10 to pos 1, 30 to pos 2, 180 stay, total 220
  125, 250, 215, 590 # Totals: 125 end in pos 1, 250 in pos 2, 215 in pos 3, grand total 590
), nrow = 4, ncol = 4)

rownames(example_structure) <- c("Class_A", "Class_B", "Class_C", "Total")
colnames(example_structure) <- c("Class_A", "Class_B", "Class_C", "Total")

print("Properly formatted mobility matrix:")
print(example_structure)
```

### Data Validation

```{r data_validation}
# Check if your data is properly formatted
validate_mobility_matrix <- function(mat) {
  n <- nrow(mat) - 1
  
  # Check row totals
  calculated_row_totals <- rowSums(mat[1:n, 1:n])
  actual_row_totals <- mat[1:n, n + 1]
  
  # Check column totals  
  calculated_col_totals <- colSums(mat[1:n, 1:n])
  actual_col_totals <- mat[n + 1, 1:n]
  
  # Check grand total
  calculated_grand_total <- sum(mat[1:n, 1:n])
  actual_grand_total <- mat[n + 1, n + 1]
  
  list(
    row_totals_match = all.equal(calculated_row_totals, actual_row_totals),
    col_totals_match = all.equal(calculated_col_totals, actual_col_totals),
    grand_total_matches = all.equal(calculated_grand_total, actual_grand_total)
  )
}

# Validate our example
validation <- validate_mobility_matrix(example_structure)
print(validation)
```

## Best Practices and Tips

### Choosing Parameters

1. **Number of levels**: Start with 3-4 levels, adjust based on your data size
2. **Cut-off values**: Default (1.0) works well for relative risk; adjust for sensitivity
3. **Small cell reduction**: Use to handle sparse data in large matrices

### Visualization Best Practices

#### Color Palette Selection
Choose palettes based on your data type and accessibility needs:

```{r palette_examples, eval=FALSE}
# For categorical data (segments)
plot_moneca_ggraph(seg, color_palette = "Set2")    # Colorblind-safe qualitative
plot_moneca_ggraph(seg, color_palette = "Dark2")   # High contrast qualitative

# For continuous data (mobility rates)
plot_moneca_ggraph(seg, node_color = "mobility", color_palette = "viridis")  # Perceptually uniform
plot_moneca_ggraph(seg, node_color = "mobility", color_palette = "plasma")   # Alternative continuous

# For comparing different systems
plot_moneca_ggraph(rigid_seg, color_palette = "Oranges")   # Sequential for one system
plot_moneca_ggraph(fluid_seg, color_palette = "Purples")   # Different sequential for comparison
```

#### Layout Algorithm Selection
Different layouts work better for different network characteristics:

```{r layout_examples, eval=FALSE}
# Force-directed layouts
plot_moneca_ggraph(seg, layout = "fr")      # Fruchterman-Reingold (balanced)
plot_moneca_ggraph(seg, layout = "kk")      # Kamada-Kawai (minimize edge crossings)

# Optimization-based layouts
plot_moneca_ggraph(seg, layout = "stress")  # Stress majorization (clean, clear)
plot_moneca_ggraph(seg, layout = "mds")     # Multidimensional scaling

# For consistent comparisons
consistent_layout <- layout.matrix(seg)     # MONECA's specialized layout
plot_moneca_ggraph(seg, layout = consistent_layout)
```

#### Node and Edge Styling
Optimize visual elements for clarity and accessibility:

```{r styling_examples, eval=FALSE}
# High contrast for presentations
plot_moneca_ggraph(seg,
  node_alpha = 0.9,        # Strong nodes
  edge_alpha = 0.4,        # Subtle edges
  edge_color = "grey20",   # Dark edges
  label_size = 4           # Large labels
)

# Detailed analysis version
plot_moneca_ggraph(seg,
  node_size = "mobility",  # Size by analytical variable
  edge_width = "weight",   # Width by connection strength
  show_segments = TRUE,    # Show cluster boundaries
  segment_alpha = 0.15     # Subtle boundaries
)
```

### Interpretation Guidelines

1. **Segments represent groups** with high internal mobility
2. **Hierarchical structure** shows nested clustering at different scales  
3. **Edge weights** indicate relative risk compared to independence
4. **Layout algorithms** can emphasize different network properties

### Performance Considerations

1. **Large matrices** (>50x50) may require increased computation time
2. **Progress bars** show optimization progress for large datasets
3. **Memory usage** grows with number of levels and matrix size

## Conclusion

MONECA provides a powerful framework for analyzing social mobility through network-based clustering. The combination of:

- Flexible clustering algorithms
- Modern visualization capabilities  
- Hierarchical segmentation
- Quality assessment tools

Makes it suitable for exploring mobility patterns in diverse social contexts.

### Further Reading

- Original MONECA methodology papers
- Network analysis in social mobility research
- Graph-theoretic approaches to social structure

### Getting Help

- Use `?function_name` for detailed function documentation
- Check the package website for updates and examples
- Report issues on the GitHub repository

```{r session_info}
# Session information for reproducibility
sessionInfo()
```