---
title: "Understanding moneca Statistics: A Comprehensive Guide"
author: "Giampaolo Montaletti"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Understanding moneca Statistics: A Comprehensive Guide}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5
)
library(moneca)
```

## Introduction

The `print.moneca()` function provides a comprehensive summary of mobility analysis results from the MONECA clustering algorithm. This vignette explains each statistic in detail with clear definitions, computational formulas, interpretations, and practical examples. The output is structured to follow the natural flow of analysis from overall patterns to detailed network metrics.

## Overview of MONECA Output

When you run a MONECA analysis and print the results, you receive a structured report organized into four main sections:

1. **Overall Mobility Patterns** - Population-level mobility summary
2. **Hierarchical Segmentation Analysis** - Level-by-level clustering results
3. **Network Structure Metrics** - Graph-theoretic properties
4. **Detailed Degree Distributions** - Node connectivity statistics (optional)

Let's start with a complete example:

```{r example-analysis}
# Generate synthetic mobility data with 30 classes for better statistical analysis
mobility_data <- generate_mobility_data(
  n_classes = 30,
  n_total = 60000,  # Larger population for better statistics
  immobility_strength = 0.7,
  class_clustering = 0.8,
  class_names = paste("Class", sprintf("%02d", 1:30)),
  seed = 123
)

cat("Mobility data dimensions:", dim(mobility_data), "\n")
cat("Total population:", mobility_data[31, 31], "\n")
cat("Overall mobility rate:", 
    round((1 - sum(diag(mobility_data[1:30, 1:30])) / sum(mobility_data[1:30, 1:30])) * 100, 1), "%\n\n")

# Show a representative subset of the mobility matrix
cat("Representative 8x8 subset of mobility matrix:\n")
subset_indices <- c(1:6, 15:16)  # First 6 classes plus middle classes
subset_matrix <- mobility_data[c(subset_indices, 31), c(subset_indices, 31)]
print(subset_matrix)

# Run MONECA analysis
seg <- moneca(mobility_data, segment.levels = 3, small.cell.reduction = 10)

# Display results
print(seg)
```

## Statistics Explained

### 1. Overall Mobility Patterns

#### Overall Population Mobility Rate

**Definition:** The percentage of the total population that experiences any form of social mobility (movement between social classes).

**Calculation:** 
$$\text{Mobility Rate} = \frac{\sum_{i \neq j} n_{ij}}{N} \times 100$$

Where:
- $n_{ij}$ = count in cell (i,j) of the mobility table
- $N$ = grand total (bottom-right cell)
- The sum excludes diagonal cells (i=j)

**Interpretation:**
- Values range from 0% (complete immobility) to 100% (everyone moves)
- Higher values indicate more fluid social structures
- Lower values suggest more rigid class boundaries
- Typical values in real data: 15-40%

```{r mobility-rate-example}
# Access the raw mobility rate from 30x30 matrix
mx <- seg$mat.list[[1]]
l <- ncol(mx)
total_population <- mx[l, l]

# Calculate mobility components
immobile_population <- sum(diag(mx[1:(l-1), 1:(l-1)]))  # Diagonal elements
mobile_population <- total_population - immobile_population
mobility_rate <- mobile_population / total_population

cat("Population statistics:\n")
cat("Total population:", total_population, "\n")
cat("Immobile population:", immobile_population, "\n")
cat("Mobile population:", mobile_population, "\n")
cat("Raw mobility rate:", round(mobility_rate * 100, 1), "%\n")

# Show mobility rates by class groups for first 10 classes
cat("\nMobility rates by class (first 10 classes):\n")
for(i in 1:10) {
  class_total <- mx[i, l]
  class_immobile <- mx[i, i]
  class_mobile <- class_total - class_immobile
  class_mobility_rate <- class_mobile / class_total
  cat("Class", sprintf("%02d", i), ":", round(class_mobility_rate * 100, 1), "%\n")
}
```

#### Average Mobility Concentration

**Definition:** The mean percentage of all mobility that occurs through statistically significant pathways (edges with relative risk > 1) across all hierarchical levels.

**Calculation:**
$$\text{Concentration}_\ell = \frac{\sum_{RR_{ij} > 1} n_{ij}}{\sum_{i} \text{rowSum}_i} \times 100$$

$$\text{Average Concentration} = \frac{1}{L} \sum_{\ell=1}^{L} \text{Concentration}_\ell$$

Where:
- $RR_{ij}$ = relative risk for edge (i,j)
- $L$ = number of hierarchical levels
- Only edges with $RR > 1$ are considered significant

**Interpretation:**
- Higher values (>80%) indicate mobility follows predictable, structured patterns
- Lower values suggest more random or dispersed mobility
- This metric helps assess whether mobility has clear "highways" or is more diffuse

### 2. Hierarchical Segmentation Analysis

#### Internal Mobility Within Segments

**Definition:** For each hierarchical level, the percentage of mobility that occurs within segments (clusters) rather than between them.

**Calculation:**
For level $\ell$:
$$\text{Internal Mobility}_\ell = \frac{\sum_{k} n_{kk}^{(\ell)}}{\sum_{i,j} n_{ij}^{(\ell)}} \times 100$$

Where:
- $n_{kk}^{(\ell)}$ = diagonal entries in the level $\ell$ aggregated matrix
- $n_{ij}^{(\ell)}$ = all entries in the level $\ell$ matrix

**Level Interpretation:**
- **Level 1:** Mobility within original social classes (baseline) - always 100% as each class is its own segment
- **Level 2+:** Mobility within identified clusters/segments after aggregation

**Pattern Analysis:**
- Decreasing percentages across levels are expected as segments combine categories
- High values (>70%) at higher levels suggest strong segment cohesion
- Values that decrease too rapidly may indicate poor clustering
- The rate of decrease indicates how much mobility crosses segment boundaries

```{r internal-mobility-detail}
# Show how internal mobility is calculated for Level 1 (30x30 system)
mx <- seg$mat.list[[1]]
l <- ncol(mx)
diagonal_sum <- sum(diag(mx[1:(l-1), 1:(l-1)]))
total_mobility <- sum(mx[1:(l-1), 1:(l-1)])
internal_mobility_pct <- (diagonal_sum / total_mobility) * 100

cat("Level 1 internal mobility calculation:\n")
cat("Diagonal sum (immobile):", diagonal_sum, "\n")
cat("Total mobility:", total_mobility, "\n")
cat("Internal mobility percentage:", round(internal_mobility_pct, 1), "%\n")

# Show how this progresses across levels
cat("\nInternal mobility progression across levels:\n")
for(level in 1:length(seg$mat.list)) {
  level_mx <- seg$mat.list[[level]]
  level_l <- ncol(level_mx)
  level_diagonal <- sum(diag(level_mx[1:(level_l-1), 1:(level_l-1)]))
  level_total <- sum(level_mx[1:(level_l-1), 1:(level_l-1)])
  level_internal_pct <- (level_diagonal / level_total) * 100
  n_segments <- level_l - 1
  cat("Level", level, ":", round(level_internal_pct, 1), "% (", n_segments, "segments)\n")
}
```

#### Mobility Concentration in Significant Pathways by Level

**Definition:** For each level, the percentage of mobility that flows through statistically significant pathways (those with relative risk > 1).

**Interpretation:**
- Shows how "channeled" mobility is at each level
- Higher values indicate more structured mobility patterns
- Useful for comparing how well each level captures mobility structure

### 3. Network Structure Metrics

```{r network-viz, fig.cap="Network visualization showing segments and connections in 30-class system", fig.width=10, fig.height=8}
# Visualize the network at Level 2 for 30-class system
# Note: Labels are turned off for clarity with 30 nodes
plot_moneca_ggraph(seg, level = 2, 
                   node_color = "segment", 
                   edge_width = "weight", 
                   layout = "fr",
                   show_labels = FALSE,  # Too cluttered for 30 nodes
                   node_alpha = 0.8,
                   edge_alpha = 0.6,
                   title = "MONECA Network (Level 2, 30 Classes)",
                   show_segments = TRUE,
                   segment_alpha = 0.2)

# Provide network statistics
cat("\nLevel 2 network statistics:\n")
cat("Number of segments:", length(seg$segment.list[[2]]), "\n")
segment_sizes <- sapply(seg$segment.list[[2]], length)
cat("Segment sizes:", paste(sort(segment_sizes, decreasing = TRUE), collapse = ", "), "\n")
cat("Average segment size:", round(mean(segment_sizes), 1), "classes\n")
cat("Largest segment size:", max(segment_sizes), "classes\n")
cat("Smallest segment size:", min(segment_sizes), "classes\n")
```

#### Active Segments/Classes per Level

**Definition:** The number of distinct segments or classes at each hierarchical level.

**Calculation:**
- Level 1: Number of original categories (excluding row/column totals)
- Level 2+: Number of segments after removing isolates (segments with size = 1)

**Pattern:**
- Decreases as segments merge at higher levels
- Rate of decrease indicates clustering aggressiveness
- Final count shows the fundamental mobility groups
- Isolates are excluded from active segment count

#### Significant Edges After Cell Size Filtering

**Definition:** The count of statistically significant mobility pathways after removing those based on small cell sizes.

**Interpretation:**
- More edges = more complex mobility patterns
- Decrease across levels shows simplification of structure
- Zero edges would indicate completely isolated segments

#### Network Connectivity Density

**Definition:** The proportion of possible edges that actually exist in the network after removing edges with relative risk â‰¤ 1.

**Calculation:**
$$\text{Density} = \frac{\text{Actual Edges}}{\text{Possible Edges}} = \frac{|E|}{n(n-1)}$$

Where:
- $|E|$ = number of edges with relative risk > 1
- $n$ = number of nodes (active segments)
- For directed networks, possible edges = $n(n-1)$
- Self-loops are excluded

**Interpretation:**
- Values range from 0 (no connections) to 1 (fully connected)
- Higher density indicates more interconnected mobility
- Often increases at higher levels as structure consolidates
- Very low density (<0.1) suggests sparse, channeled mobility

#### Isolated Segments

**Definition:** The count of segments/classes with no statistically significant mobility connections to other segments. A segment is isolated if it has degree = 0 in the network (no edges with relative risk > 1).

**Technical Details:**
- Calculated as nodes with total degree = 0 after filtering edges by relative risk
- Isolates can still have internal mobility (high diagonal values)
- Different from segments of size 1, which are removed before analysis

**Interpretation:**
- Higher numbers indicate fragmented social structure
- Zero isolates means all segments are connected via significant pathways
- Isolates may represent:
  - Truly closed social groups with only internal mobility
  - Positions that exchange members only weakly with others
  - Categories at the extremes of the social hierarchy

### 4. Detailed Degree Distributions

When `show.degree.stats = TRUE` (default), additional network statistics are displayed:

```{r degree-stats-example}
# Show results without degree statistics for comparison
print(seg, show.degree.stats = FALSE)
```

#### Degree Types Explained

1. **Total Connections (All Degrees):** Sum of inward and outward connections
2. **Outward Mobility:** Number of destinations a segment sends people to
3. **Inward Mobility:** Number of origins a segment receives people from
4. **Edge Weights:** Strength of connections (relative risk values)

#### Reading the Distribution Tables

Each table shows six statistics:
- **Min:** Lowest value in the distribution
- **Q1:** First quartile (25th percentile)
- **Median:** Middle value (50th percentile)
- **Mean:** Average value
- **Q3:** Third quartile (75th percentile)
- **Max:** Highest value in the distribution

## Practical Interpretation Guide

### Step-by-Step Analysis

1. **Start with Total Mobility**
   - Is the system fluid or rigid?
   - Compare to known benchmarks or expectations
   - Consider: <30% = rigid, 30-50% = moderate, >50% = fluid

2. **Check Edge Concentration**
   - Are there clear mobility pathways?
   - Or is movement more random?
   - High concentration (>80%) = structured pathways
   - Low concentration (<60%) = dispersed mobility

3. **Examine Internal Mobility Progression**
   - Level 1 is always 100% (baseline)
   - Good clustering: Level 2 >80%, Level 3 >70%
   - Poor clustering: Rapid drop to <50%
   - Note: Some decrease is natural and expected

4. **Review Network Metrics**
   - Density trajectory: Should generally increase with levels
   - Active segments: Rate of consolidation
   - Isolates: Presence indicates fragmentation
   - Edge count: Complexity of mobility patterns

5. **Analyze Degree Distributions (if shown)**
   - Mean > Median = few hubs with many connections
   - Mean â‰ˆ Median = evenly distributed connections
   - Max degree identifies central positions
   - Zero minimum indicates isolates present

### Example Interpretation

Let's interpret our example results:

```{r interpretation-example}
# Create a different mobility pattern for comparison (30x30)
mobility_data2 <- generate_mobility_data(
  n_classes = 30,
  n_total = 45000,
  immobility_strength = 0.9,  # Much less mobility
  class_clustering = 0.5,     # Less structured
  class_names = paste("Class", sprintf("%02d", 1:30)),
  seed = 456
)

seg2 <- moneca(mobility_data2, segment.levels = 3, small.cell.reduction = 10)

cat("Comparison of two 30-class mobility systems:\n\n")

# Calculate key statistics for comparison
compare_stats <- function(seg_obj, data_matrix, system_name) {
  mx <- seg_obj$mat.list[[1]]
  l <- ncol(mx)
  total_pop <- mx[l, l]
  mobile_pop <- total_pop - sum(diag(mx[1:(l-1), 1:(l-1)]))
  mobility_rate <- mobile_pop / total_pop * 100
  
  n_segments_l2 <- length(seg_obj$segment.list[[2]])
  n_segments_l3 <- length(seg_obj$segment.list[[3]])
  
  # Internal mobility at level 2
  mx2 <- seg_obj$mat.list[[2]]
  l2 <- ncol(mx2)
  internal_l2 <- sum(diag(mx2[1:(l2-1), 1:(l2-1)])) / sum(mx2[1:(l2-1), 1:(l2-1)]) * 100
  
  cat(system_name, ":\n")
  cat("  Overall mobility rate:", round(mobility_rate, 1), "%\n")
  cat("  Segments at Level 2:", n_segments_l2, "\n")
  cat("  Segments at Level 3:", n_segments_l3, "\n")
  cat("  Internal mobility (L2):", round(internal_l2, 1), "%\n")
  cat("  Population:", total_pop, "\n\n")
}

compare_stats(seg, mobility_data, "System 1 (More fluid, clustering=0.8)")
compare_stats(seg2, mobility_data2, "System 2 (More rigid, clustering=0.5)")

cat("System 1 (More fluid) - detailed output:\n")
print(seg, show.degree.stats = FALSE, digits = 1)

cat("\n\nSystem 2 (More rigid) - detailed output:\n")
print(seg2, show.degree.stats = FALSE, digits = 1)
```

## Understanding the Computational Process

### Relative Risk Calculation

The foundation of MONECA is the relative risk matrix, calculated as:

```{r relative-risk-demo}
# Demonstrate relative risk calculation for 30x30 matrix
mx <- seg$mat.list[[1]]
l <- nrow(mx)

# Extract marginals
row_totals <- mx[-l, l]
col_totals <- mx[l, -l]
grand_total <- mx[l, l]

cat("Relative risk calculation components:\n")
cat("Matrix dimensions:", dim(mx), "\n")
cat("Grand total:", grand_total, "\n")
cat("Row totals range:", min(row_totals), "-", max(row_totals), "\n")
cat("Column totals range:", min(col_totals), "-", max(col_totals), "\n\n")

# Calculate expected values under independence
expected <- outer(row_totals, col_totals) / grand_total

# Calculate relative risks
observed <- mx[-l, -l]
relative_risk <- observed / expected

# Show subset of relative risk matrix
cat("Sample of relative risk matrix (first 8x8):\n")
print(round(relative_risk[1:8, 1:8], 2))

# Show distribution of relative risk values
rr_diagonal <- diag(relative_risk)
rr_offdiagonal <- relative_risk[upper.tri(relative_risk) | lower.tri(relative_risk)]

cat("\nRelative risk statistics:\n")
cat("Diagonal (immobility) RR - Mean:", round(mean(rr_diagonal), 2), 
    "Range:", round(min(rr_diagonal), 2), "-", round(max(rr_diagonal), 2), "\n")
cat("Off-diagonal (mobility) RR - Mean:", round(mean(rr_offdiagonal), 2),
    "Range:", round(min(rr_offdiagonal), 2), "-", round(max(rr_offdiagonal), 2), "\n")

# Count significant edges
significant_edges <- sum(relative_risk > 1 & !is.na(relative_risk))
total_possible <- 30 * 30
cat("Significant edges (RR > 1):", significant_edges, "out of", total_possible, 
    "(", round(significant_edges/total_possible*100, 1), "%)\n")
```

### Clique Detection Process

MONECA identifies segments through clique detection in the weighted network:

1. Convert relative risk matrix to adjacency matrix (RR > 1)
2. Find all maximal cliques in the resulting graph
3. Select cliques that maximize internal mobility
4. Assign each node to its best clique based on connection strength

### Hierarchical Aggregation

After identifying segments at each level:

```{r aggregation-demo}
# Show how matrices are aggregated across levels in 30-class system
cat("Matrix dimensions across hierarchical levels:\n")
for(level in 1:length(seg$mat.list)) {
  dims <- dim(seg$mat.list[[level]])
  n_classes <- dims[1] - 1
  total_pop <- seg$mat.list[[level]][dims[1], dims[2]]
  cat("Level", level, ":", dims[1], "x", dims[2], "(", n_classes, "classes/segments,", 
      "population:", total_pop, ")\n")
}

cat("\nSegmentation details:\n")
for(level in 1:length(seg$segment.list)) {
  n_segments <- length(seg$segment.list[[level]])
  if(level == 1) {
    cat("Level", level, ": Individual classes (", n_segments, "classes)\n")
  } else {
    segment_sizes <- sapply(seg$segment.list[[level]], length)
    cat("Level", level, ": ", n_segments, "segments, sizes:", 
        paste(sort(segment_sizes, decreasing = TRUE), collapse = ", "), "\n")
  }
}

# Demonstrate aggregation principle with example
cat("\nAggregation principle:\n")
cat("For Level 2, cell (i,j) = sum of all original cells where\n")
cat("  origin class belongs to segment i AND destination class belongs to segment j\n")

# Show example of how first segment maps to original classes
if(length(seg$segment.list) >= 2 && length(seg$segment.list[[2]]) > 0) {
  first_segment <- seg$segment.list[[2]][[1]]
  cat("\nExample - First segment at Level 2 contains classes:", 
      paste(first_segment, collapse = ", "), "\n")
  
  # Calculate what contributes to position (1,1) in Level 2 matrix
  original_contributions <- 0
  for(i in first_segment) {
    for(j in first_segment) {
      contribution <- seg$mat.list[[1]][i, j]
      original_contributions <- original_contributions + contribution
    }
  }
  level2_cell_11 <- seg$mat.list[[2]][1, 1]
  cat("Sum of original cells in segment 1 -> segment 1:", original_contributions, "\n")
  cat("Level 2 matrix cell (1,1):", level2_cell_11, "\n")
  cat("Match:", original_contributions == level2_cell_11, "\n")
}
```

## Advanced Usage

### Customizing Output

```{r custom-output}
# Show more decimal places for precise analysis of 30-class system
cat("High-precision output for 30-class system:\n")
print(seg, digits = 2, show.degree.stats = FALSE)

# Compare different small cell reduction thresholds
cat("\n\nComparison with different small cell reduction thresholds:\n")
cat("Standard threshold (10):\n")
print(seg, small.cell.reduction = 10, show.degree.stats = FALSE)

cat("\nHigher threshold (25) - more conservative:\n")
seg_conservative <- moneca(mobility_data, segment.levels = 3, small.cell.reduction = 25)
print(seg_conservative, small.cell.reduction = 25, show.degree.stats = FALSE)

# Compare the effect of different thresholds
cat("\nEffect of small cell reduction threshold:\n")
cat("Threshold 10 - Segments at L2:", length(seg$segment.list[[2]]), 
    ", L3:", length(seg$segment.list[[3]]), "\n")
cat("Threshold 25 - Segments at L2:", length(seg_conservative$segment.list[[2]]), 
    ", L3:", length(seg_conservative$segment.list[[3]]), "\n")
```

### Accessing Raw Statistics

While `print.moneca()` provides formatted output, you can access the raw statistics for further analysis:

```{r raw-stats}
# The MONECA object contains all the raw data for 30-class system
cat("MONECA object structure overview:\n")
cat("Class:", class(seg), "\n")
cat("Components:", names(seg), "\n")
cat("Number of hierarchical levels:", length(seg$segment.list), "\n")

# Show detailed structure (limiting depth for readability)
str(seg, max.level = 1)

# Access and summarize specific components
cat("\nDetailed component analysis:\n")
cat("Number of matrices:", length(seg$mat.list), "\n")
for(i in 1:length(seg$mat.list)) {
  dims <- dim(seg$mat.list[[i]])
  cat("Matrix", i, "dimensions:", dims[1], "x", dims[2], "\n")
}

cat("\nSegment memberships by level:\n")
for(i in 1:length(seg$segment.list)) {
  if(i == 1) {
    n_segments <- length(seg$segment.list[[i]])
    cat("Level", i, ": Individual classes (1 to", n_segments, ")\n")
  } else {
    # seg$segment.list[[i]] is a list of segments, each containing class indices
    n_segments <- length(seg$segment.list[[i]])
    segment_sizes <- sapply(seg$segment.list[[i]], length)
    cat("Level", i, ": ", n_segments, "segments with sizes:", 
        paste(sort(segment_sizes, decreasing = TRUE), collapse = ", "), "\n")
  }
}

# Show sample segment memberships for first 15 classes
cat("\nSample segment memberships (first 15 classes):\n")
if(length(seg$segment.list) >= 2) {
  # Use segment.membership() function to get proper membership vectors
  membership <- segment.membership(seg)
  
  sample_df <- data.frame(
    Class = 1:15,
    Level_1 = membership[[1]][1:15]
  )
  
  if(length(membership) >= 2) {
    sample_df$Level_2 <- membership[[2]][1:15]
  }
  
  if(length(membership) >= 3) {
    sample_df$Level_3 <- membership[[3]][1:15]
  }
  
  print(sample_df)
}
```

## Common Patterns and Their Meanings

### Pattern 1: Strong Hierarchical Structure
- Internal mobility increases substantially across levels
- Network density increases at higher levels
- Few or no isolated segments
- **Interpretation:** Clear nested mobility structure

### Pattern 2: Weak Structure
- Internal mobility shows little increase
- Many isolated segments
- Low edge concentration
- **Interpretation:** Mobility is more random than structured

### Pattern 3: Polarized System
- High internal mobility even at Level 1
- Very low overall mobility rate
- High number of isolated segments
- **Interpretation:** Rigid class boundaries with little inter-class movement

## Troubleshooting

### Issue: Very High Network Density
**Cause:** Small cell reduction threshold too low
**Solution:** Increase `small.cell.reduction` parameter

### Issue: Many Isolated Segments
**Cause:** Threshold too high or genuinely fragmented structure
**Solution:** Check threshold or examine data for truly isolated groups

### Issue: No Change Across Levels
**Cause:** Data may lack hierarchical structure
**Solution:** Consider fewer levels or different clustering parameters

## Conclusion

The enhanced `print.moneca()` output provides a comprehensive view of mobility patterns and their hierarchical structure. By understanding each statistic and their relationships, researchers can:

1. Assess overall social fluidity
2. Identify structured mobility pathways
3. Discover hierarchical clustering in mobility patterns
4. Compare different populations or time periods
5. Validate theoretical models of social mobility

For more information on MONECA methodology, see `vignette("moneca-introduction")`. For visualization options, see the documentation for `plot_moneca_ggraph()`.