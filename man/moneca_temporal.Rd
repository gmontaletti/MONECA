% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/temporal_clustering.R
\name{moneca_temporal}
\alias{moneca_temporal}
\title{Temporal Mobility Network Clustering Analysis}
\usage{
moneca_temporal(
  matrix_list,
  window_size = 3,
  segment.levels = 3,
  stability_method = "hungarian",
  aggregation_method = "mean",
  cut.off = 1,
  small.cell.reduction = 0,
  min_overlap = 0.5,
  parallel = FALSE,
  verbose = TRUE,
  ...
)
}
\arguments{
\item{matrix_list}{List of mobility matrices, one for each time period. Each matrix
must be square with identical dimensions and row/column names.}

\item{window_size}{Integer specifying the number of time periods to include in each
moving window. Default is 3.}

\item{segment.levels}{Integer specifying the maximum number of hierarchical 
segmentation levels. Default is 3.}

\item{stability_method}{Character string specifying the method for matching segments
across time periods:
\itemize{
  \item "hungarian" (default): Uses Hungarian algorithm for optimal bipartite matching
  \item "jaccard": Uses Jaccard similarity of segment memberships
  \item "overlap": Simple overlap coefficient
}}

\item{aggregation_method}{Character string specifying how to combine matrices within
each window:
\itemize{
  \item "mean" (default): Average of matrices in window
  \item "sum": Sum of matrices
  \item "weighted": Weighted average with more recent periods having higher weight
}}

\item{cut.off}{Numeric threshold for minimum relative risk. Default is 1.}

\item{small.cell.reduction}{Numeric value for handling small cells. Default is 0.}

\item{min_overlap}{Minimum proportion of nodes that must overlap between segments
for matching. Default is 0.5.}

\item{parallel}{Logical indicating whether to use parallel processing for windows.
When TRUE, windows are processed in parallel using multiple CPU cores, which can
significantly speed up analysis for large datasets. Uses mclapply on Unix/Mac
and parLapply on Windows. Default is FALSE.}

\item{verbose}{Logical indicating whether to show progress messages. Default is TRUE.}

\item{...}{Additional arguments passed to moneca().}
}
\value{
An object of class "moneca_temporal" containing:
  \describe{
    \item{windows}{List of time windows analyzed (start and end periods)}
    \item{segment_maps}{List of segment membership matrices for each window}
    \item{stable_labels}{Consistently labeled segments across all time periods}
    \item{transition_matrix}{Matrix showing segment-to-segment transitions}
    \item{moneca_results}{List of full moneca objects for each window}
    \item{matching_history}{Details of segment matching between windows}
    \item{parameters}{List of analysis parameters used}
  }
}
\description{
Performs moving window clustering analysis on a time series of mobility matrices,
maintaining stable segment labels across time periods. This function extends MONECA
to handle temporal data by analyzing overlapping windows of mobility matrices and
tracking how segments evolve over time.
}
\details{
The function performs the following steps:
1. Creates overlapping windows of specified size from the input matrices
2. Aggregates matrices within each window according to aggregation_method
3. Runs moneca clustering on each aggregated window
4. Matches segments between consecutive windows to maintain label stability
5. Tracks transitions and changes in segment composition

Segment matching uses either the Hungarian algorithm for optimal assignment
based on membership overlap, or Jaccard similarity for simpler matching.
The function ensures that segment labels remain as consistent as possible
across time periods, making it easier to track segment evolution.
}
\examples{
\dontrun{
# Generate synthetic monthly mobility data
months_data <- lapply(1:12, function(m) {
  generate_mobility_data(n_classes = 6, seed = m * 100)
})

# Run temporal analysis with 3-month moving window (sequential)
temporal_result <- moneca_temporal(
  matrix_list = months_data,
  window_size = 3,
  segment.levels = 3,
  stability_method = "hungarian",
  verbose = TRUE
)

# Run with parallel processing for faster execution
temporal_result_parallel <- moneca_temporal(
  matrix_list = months_data,
  window_size = 3,
  segment.levels = 3,
  stability_method = "hungarian",
  parallel = TRUE,  # Enable parallel processing
  verbose = TRUE
)

# Print summary
print(temporal_result)

# Analyze stability
stability <- temporal_stability_analysis(temporal_result)
}

}
\seealso{
\code{\link{moneca}} for single-period analysis,
\code{\link{temporal_stability_analysis}} for stability metrics,
\code{\link{plot_temporal_segments}} for visualization
}
