% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/auto_tuning.R
\name{auto_tune_small_cell_reduction}
\alias{auto_tune_small_cell_reduction}
\title{Enhanced Automatic Small Cell Reduction Parameter Tuning with Multi-Objective Optimization}
\usage{
auto_tune_small_cell_reduction(
  mx,
  cut.off = 1,
  method = "stability",
  n_trials = 10,
  candidate_values = NULL,
  performance_weight = 0.3,
  min_density = 0.01,
  max_candidates = 20,
  seed = NULL,
  verbose = FALSE,
  use_cache = TRUE,
  parallel = "auto",
  early_stopping = TRUE,
  pareto_objectives = c("quality", "performance"),
  cv_folds = 5,
  bayesian_iterations = 20
)
}
\arguments{
\item{mx}{Mobility matrix to analyze. Must be a square numeric matrix 
representing mobility flows between categories.}

\item{cut.off}{Numeric threshold for edge weights in network construction. 
Default is 1.}

\item{method}{Character string specifying tuning strategy. Options are:
\itemize{
  \item "stability" (default): Bootstrap-based stability assessment
  \item "quality": Clustering quality optimization using silhouette and modularity
  \item "performance": Balance between quality and computational efficiency
  \item "pareto": Multi-objective optimization with Pareto frontier analysis
  \item "cross_validation": Cross-validation based parameter selection
  \item "bayesian": Bayesian optimization (requires GPfit package)
}}

\item{n_trials}{Integer number of trials for stability assessment or CV folds. Default is 10.}

\item{candidate_values}{Numeric vector of candidate values to test. If NULL,
values are generated automatically using data-driven methods.}

\item{performance_weight}{Numeric weight (0-1) for performance vs quality 
trade-off. Higher values prioritize speed over quality. Default is 0.3.}

\item{min_density}{Minimum acceptable network density threshold. Default is 0.01.}

\item{max_candidates}{Maximum number of candidate values to evaluate for 
computational efficiency. Default is 20.}

\item{seed}{Integer seed for reproducible results in bootstrap sampling. 
Default is NULL.}

\item{verbose}{Logical indicating whether to show progress messages. 
Default is FALSE.}

\item{use_cache}{Logical indicating whether to use caching for repeated computations.
Default is TRUE.}

\item{parallel}{Character or logical indicating parallel processing preference.
Can be "auto" (default, intelligent switching), TRUE/FALSE (force parallel/sequential),
or "parallel"/"sequential" for explicit control.}

\item{early_stopping}{Logical indicating whether to use early stopping for
candidate screening. Default is TRUE.}

\item{pareto_objectives}{Character vector of objectives for Pareto optimization.
Default is c("quality", "performance").}

\item{cv_folds}{Integer number of cross-validation folds. Default is 5.}

\item{bayesian_iterations}{Integer number of Bayesian optimization iterations.
Default is 20.}
}
\value{
A list containing:
  \item{optimal_value}{Recommended small.cell.reduction parameter value}
  \item{stability_scores}{Stability assessment results for each candidate}
  \item{quality_metrics}{Clustering quality metrics for each candidate}
  \item{performance_metrics}{Computational performance metrics}
  \item{candidates_tested}{Vector of candidate values evaluated}
  \item{tuning_method}{Method used for parameter selection}
  \item{selection_rationale}{Text explanation of parameter selection}
  \item{network_properties}{Network density and connectivity metrics}
  \item{computation_time}{Total time spent on parameter tuning}
}
\description{
Automatically selects optimal small.cell.reduction parameter for MONECA 
clustering using advanced optimization methods including Pareto frontier analysis,
cross-validation, Bayesian optimization, and performance-aware tuning.
This enhanced version provides significant speed improvements while maintaining
or improving tuning quality.
}
\details{
The function implements three tuning strategies:

\strong{Stability Method:} Uses bootstrap resampling to assess clustering 
consistency across data subsamples. Parameters that produce more stable 
clustering structures are preferred.

\strong{Quality Method:} Optimizes clustering quality using multiple metrics 
including silhouette coefficients, network modularity, and information-theoretic 
measures.

\strong{Performance Method:} Balances clustering quality with computational 
efficiency, considering both analysis time and memory requirements.

Candidate values are automatically generated using percentile-based thresholds, 
matrix sparsity analysis, and network density targets unless explicitly provided.
}
\examples{
\dontrun{
# Generate sample mobility data
mobility_data <- generate_mobility_data(n_classes = 6, seed = 123)

# Stability-based tuning (recommended)
tuning_result <- auto_tune_small_cell_reduction(
  mx = mobility_data, 
  method = "stability",
  n_trials = 15,
  verbose = TRUE
)

# Use optimal parameter in moneca analysis
segments <- moneca(mobility_data, 
                  small.cell.reduction = tuning_result$optimal_value)

# Quality-based tuning with custom candidates
quality_result <- auto_tune_small_cell_reduction(
  mx = mobility_data,
  method = "quality", 
  candidate_values = c(0, 1, 2, 5, 10, 20),
  verbose = TRUE
)

# Performance-aware tuning
performance_result <- auto_tune_small_cell_reduction(
  mx = mobility_data,
  method = "performance",
  performance_weight = 0.5,  # Equal weight to speed and quality
  verbose = TRUE
)
}

}
\seealso{
\code{\link{moneca}} for main clustering function,
\code{\link{weight.matrix}} for weight matrix computation,
\code{\link{generate_candidate_values}} for candidate generation,
\code{\link{assess_clustering_stability}} for stability assessment
}
