% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/auto_tuning_enhanced.R
\name{auto_tune_small_cell_reduction_enhanced}
\alias{auto_tune_small_cell_reduction_enhanced}
\title{Enhanced Automatic Small Cell Reduction Parameter Tuning with Multi-Objective Optimization}
\usage{
auto_tune_small_cell_reduction_enhanced(
  mx,
  cut.off = 1,
  method = "stability",
  n_trials = 10,
  candidate_values = NULL,
  performance_weight = 0.3,
  min_density = 0.01,
  max_candidates = 20,
  seed = NULL,
  verbose = FALSE,
  use_cache = TRUE,
  parallel_cores = NULL,
  early_stopping = TRUE,
  pareto_objectives = c("quality", "performance"),
  cv_folds = 5,
  bayesian_iterations = 20
)
}
\arguments{
\item{mx}{Mobility matrix to analyze. Must be a square numeric matrix 
representing mobility flows between categories.}

\item{cut.off}{Numeric threshold for edge weights in network construction. 
Default is 1.}

\item{method}{Character string specifying tuning strategy. Options are:
\itemize{
  \item "stability" (default): Bootstrap-based stability assessment
  \item "quality": Clustering quality optimization using silhouette and modularity
  \item "performance": Balance between quality and computational efficiency
  \item "pareto": Multi-objective optimization with Pareto frontier analysis
  \item "cross_validation": Cross-validation based parameter selection
  \item "bayesian": Bayesian optimization (requires DiceKriging package)
}}

\item{n_trials}{Integer number of trials for stability assessment or CV folds. Default is 10.}

\item{candidate_values}{Numeric vector of candidate values to test. If NULL,
values are generated automatically using data-driven methods.}

\item{performance_weight}{Numeric weight (0-1) for performance vs quality 
trade-off. Higher values prioritize speed over quality. Default is 0.3.}

\item{min_density}{Minimum acceptable network density threshold. Default is 0.01.}

\item{max_candidates}{Maximum number of candidate values to evaluate for 
computational efficiency. Default is 20.}

\item{seed}{Integer seed for reproducible results in bootstrap sampling. 
Default is NULL.}

\item{verbose}{Logical indicating whether to show progress messages. 
Default is FALSE.}

\item{use_cache}{Logical indicating whether to use caching for repeated computations.
Default is TRUE.}

\item{parallel_cores}{Integer number of cores for parallel processing. Default is NULL
(auto-detect).}

\item{early_stopping}{Logical indicating whether to use early stopping for
candidate screening. Default is TRUE.}

\item{pareto_objectives}{Character vector of objectives for Pareto optimization.
Default is c("quality", "performance").}

\item{cv_folds}{Integer number of cross-validation folds. Default is 5.}

\item{bayesian_iterations}{Integer number of Bayesian optimization iterations.
Default is 20.}
}
\value{
A list containing:
  \item{optimal_value}{Recommended small.cell.reduction parameter value}
  \item{stability_scores}{Stability assessment results for each candidate}
  \item{quality_metrics}{Clustering quality metrics for each candidate}
  \item{performance_metrics}{Computational performance metrics}
  \item{candidates_tested}{Vector of candidate values evaluated}
  \item{tuning_method}{Method used for parameter selection}
  \item{selection_rationale}{Text explanation of parameter selection}
  \item{network_properties}{Network density and connectivity metrics}
  \item{computation_time}{Total time spent on parameter tuning}
  \item{pareto_solutions}{Pareto frontier analysis (if method = "pareto")}
  \item{cv_results}{Cross-validation results (if method = "cross_validation")}
  \item{bayesian_results}{Bayesian optimization results (if method = "bayesian")}
}
\description{
Automatically selects optimal small.cell.reduction parameter for MONECA 
clustering using advanced optimization methods including Pareto frontier analysis,
cross-validation, Bayesian optimization, and performance-aware tuning.
This enhanced version provides significant speed improvements while maintaining
or improving tuning quality.
}
\examples{
\dontrun{
# Generate sample mobility data
mobility_data <- generate_mobility_data(n_classes = 6, seed = 123)

# Multi-objective Pareto optimization (NEW)
pareto_result <- auto_tune_small_cell_reduction_enhanced(
  mx = mobility_data, 
  method = "pareto",
  pareto_objectives = c("quality", "performance", "stability"),
  verbose = TRUE
)

# Cross-validation with confidence intervals (NEW)
cv_result <- auto_tune_small_cell_reduction_enhanced(
  mx = mobility_data,
  method = "cross_validation",
  cv_folds = 10,
  verbose = TRUE
)

# Bayesian optimization (NEW)
bayesian_result <- auto_tune_small_cell_reduction_enhanced(
  mx = mobility_data,
  method = "bayesian",
  bayesian_iterations = 30,
  verbose = TRUE
)

# Enhanced stability tuning with parallel processing
stability_result <- auto_tune_small_cell_reduction_enhanced(
  mx = mobility_data, 
  method = "stability",
  parallel_cores = 4,
  use_cache = TRUE,
  early_stopping = TRUE,
  verbose = TRUE
)

# Visualize results
plot_tuning_results(pareto_result, plot_type = "all")
parameter_sensitivity_plot(cv_result)
performance_quality_tradeoff_plot(stability_result)
}

}
\seealso{
\code{\link{auto_tune_small_cell_reduction}} for the original function,
\code{\link{moneca}} for main clustering function,
\code{\link{plot_tuning_results}} for visualization,
\code{\link{parameter_sensitivity_plot}} for sensitivity analysis
}
