% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/joint_tuning.R
\name{auto_tune_joint_parameters}
\alias{auto_tune_joint_parameters}
\title{Joint Auto-Tuning for small.cell.reduction and cut.off Parameters}
\usage{
auto_tune_joint_parameters(
  mx,
  method = "grid",
  scr_range = c(0, NULL),
  cutoff_range = c(0.5, 3),
  n_grid_points = 10,
  n_bootstrap = 50,
  objectives = c("stability", "quality"),
  weights = NULL,
  seed = NULL,
  verbose = TRUE,
  parallel = "auto",
  plot_surface = FALSE
)
}
\arguments{
\item{mx}{Mobility matrix to analyze. Must be a square numeric matrix.}

\item{method}{Character string specifying optimization strategy:
\itemize{
  \item "grid" (default): 2D grid search with stability assessment
  \item "bayesian": Bayesian optimization in joint parameter space
  \item "pareto": Multi-objective Pareto frontier optimization
  \item "adaptive": Adaptive refinement starting with coarse grid
}}

\item{scr_range}{Numeric vector of length 2 specifying the range for 
small.cell.reduction parameter. Default is c(0, NULL) where NULL 
auto-determines the upper bound.}

\item{cutoff_range}{Numeric vector of length 2 specifying the range for 
cut.off parameter. Default is c(0.5, 3).}

\item{n_grid_points}{Integer number of grid points per dimension for grid 
search. Default is 10.}

\item{n_bootstrap}{Integer number of bootstrap samples for stability 
assessment. Default is 50.}

\item{objectives}{Character vector of optimization objectives. Options include:
"stability", "quality", "sparsity", "modularity". 
Default is c("stability", "quality").}

\item{weights}{Numeric vector of weights for combining multiple objectives.
Must sum to 1. Default is equal weights.}

\item{seed}{Integer seed for reproducibility. Default is NULL.}

\item{verbose}{Logical indicating whether to show progress. Default is TRUE.}

\item{parallel}{Character or logical indicating parallel processing preference.
Can be "auto" (default, intelligent switching), TRUE/FALSE (force parallel/sequential),
or "parallel"/"sequential" for explicit control. When "auto", the function
analyzes problem characteristics and system resources to make optimal decision.}

\item{plot_surface}{Logical indicating whether to plot optimization surface.
Default is FALSE.}
}
\value{
A list of class "moneca_joint_tuning" containing:
  \item{optimal_scr}{Optimal small.cell.reduction value}
  \item{optimal_cutoff}{Optimal cut.off value}
  \item{optimization_surface}{Matrix of objective values for parameter grid}
  \item{parameter_grid}{Data frame of tested parameter combinations}
  \item{scores}{Detailed scores for each parameter combination}
  \item{method}{Optimization method used}
  \item{objectives}{Objectives optimized}
  \item{selection_rationale}{Explanation of parameter selection}
  \item{mathematical_relationship}{Estimated interaction effects}
  \item{computation_time}{Total optimization time}
}
\description{
Automatically selects optimal values for both small.cell.reduction and cut.off 
parameters simultaneously, considering their mathematical relationships and 
compound effects on clustering results.
}
\details{
The function considers the mathematical relationship between parameters:

\strong{Sequential Filtering:}
1. small.cell.reduction filters raw counts: mx[mx < scr] = 0
2. Relative risk calculation: RR = Observed / Expected
3. cut.off filters relative risks: RR[RR < cutoff] = NA

\strong{Compound Effects:}
Network density is affected multiplicatively by both parameters.
The function models this interaction to find optimal combinations.
}
\examples{
\dontrun{
# Generate sample data
mobility_data <- generate_mobility_data(n_classes = 6, seed = 123)

# Grid search optimization
joint_result <- auto_tune_joint_parameters(
  mx = mobility_data,
  method = "grid",
  n_grid_points = 15,
  verbose = TRUE,
  plot_surface = TRUE
)

# Use optimal parameters
segments <- moneca(
  mobility_data,
  small.cell.reduction = joint_result$optimal_scr,
  cut.off = joint_result$optimal_cutoff
)

# Adaptive refinement for efficiency
adaptive_result <- auto_tune_joint_parameters(
  mx = mobility_data,
  method = "adaptive",
  verbose = TRUE
)
}

}
\seealso{
\code{\link{auto_tune_small_cell_reduction}},
\code{\link{analyze_parameter_interaction}},
\code{\link{visualize_parameter_space}}
}
