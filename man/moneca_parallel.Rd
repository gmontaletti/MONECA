% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parallel_moneca.R
\name{moneca_parallel}
\alias{moneca_parallel}
\title{Parallel moneca - High-Performance Mobility Network Clustering Analysis}
\usage{
moneca_parallel(
  mx = mx,
  segment.levels = 3,
  cut.off = 1,
  mode = "symmetric",
  delete.upper.tri = TRUE,
  small.cell.reduction = 0,
  n.cores = NULL,
  parallel.backend = "auto",
  chunk.size = NULL,
  fallback.sequential = TRUE,
  progress = TRUE,
  auto_tune = FALSE,
  tune_method = "stability",
  tune_verbose = FALSE
)
}
\arguments{
\item{mx}{A mobility table (square matrix) with row and column totals in the last
row/column. Row names should identify the categories/classes.}

\item{segment.levels}{Integer specifying the number of hierarchical segmentation 
levels to compute. Default is 3.}

\item{cut.off}{Numeric threshold for the minimum relative risk to be considered
a significant tie. Default is 1.}

\item{mode}{Character string specifying edge mode ("symmetric", "Mutual", or 
"Unmutual"). Default is "symmetric".}

\item{delete.upper.tri}{Logical indicating whether to use only lower triangle 
for efficiency. Default is TRUE.}

\item{small.cell.reduction}{Numeric value to handle small cell counts. Cells with
counts below this threshold are set to 0. Default is 0.}

\item{n.cores}{Integer specifying the number of CPU cores to use. Default is NULL
(auto-detect optimal number).}

\item{parallel.backend}{Character string specifying the parallel backend:
"auto" (default), "fork" (Unix/Mac only), or "socket" (all platforms).}

\item{chunk.size}{Integer specifying the chunk size for parallel processing.
Default is NULL (auto-calculate based on data size).}

\item{fallback.sequential}{Logical indicating whether to fall back to sequential
processing if parallel fails. Default is TRUE.}

\item{progress}{Logical indicating whether to show progress bars. Default is TRUE.}

\item{auto_tune}{Logical indicating whether to automatically tune the 
small.cell.reduction parameter. When TRUE, uses optimization methods to
select the best value. Default is FALSE.}

\item{tune_method}{Character string specifying the auto-tuning method when
auto_tune is TRUE. Options are "stability" (default), "quality", or 
"performance". See \code{\link{auto_tune_small_cell_reduction}} for details.}

\item{tune_verbose}{Logical indicating whether to print verbose messages
during auto-tuning. Default is FALSE.}
}
\value{
An object of class "moneca" containing:
  \describe{
    \item{segment.list}{A list of segment memberships for each hierarchical level.}
    \item{mat.list}{A list of aggregated mobility matrices for each level.}
    \item{small.cell.reduction}{The small cell reduction parameter used.}
    \item{performance}{Performance metrics including timing and speedup (if parallel).}
  }
}
\description{
Parallel implementation of the moneca algorithm leveraging multiple CPU cores
for improved performance on large datasets. This implementation maintains
full compatibility with the original moneca() function while providing
significant speedups through parallelization.
}
\details{
The parallel implementation uses several strategies to improve performance:
\itemize{
  \item Parallel clique detection in find.segments
  \item Vectorized and parallel matrix operations in weight.matrix
  \item Parallel aggregation in segment.matrix
  \item Automatic load balancing and chunk size optimization
  \item Intelligent fallback to sequential processing when beneficial
}
}
\examples{
\dontrun{
# Generate test data
test_data <- generate_mobility_data(n_classes = 100, seed = 123)

# Run parallel analysis (auto-detect cores)
result <- moneca_parallel(test_data, segment.levels = 3)

# Run with specific number of cores
result <- moneca_parallel(test_data, segment.levels = 3, n.cores = 4)

# Force socket backend for Windows compatibility
result <- moneca_parallel(test_data, parallel.backend = "socket")
}

}
